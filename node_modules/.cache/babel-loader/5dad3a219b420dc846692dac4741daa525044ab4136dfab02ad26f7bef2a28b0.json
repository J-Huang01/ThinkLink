{"ast":null,"code":"import _regeneratorRuntime from \"/Users/huangjiatan/Desktop/today_i_learned/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"/Users/huangjiatan/Desktop/today_i_learned/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"/Users/huangjiatan/Desktop/today_i_learned/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport GoTrueAdminApi from './GoTrueAdminApi';\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants';\nimport { AuthImplicitGrantRedirectError, AuthPKCEGrantCodeExchangeError, AuthInvalidCredentialsError, AuthRetryableFetchError, AuthSessionMissingError, AuthInvalidTokenResponseError, AuthUnknownError, isAuthApiError, isAuthError } from './lib/errors';\nimport { _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch';\nimport { decodeJWTPayload, Deferred, getItemAsync, getParameterByName, isBrowser, removeItemAsync, resolveFetch, setItemAsync, uuid, retryable, sleep, generatePKCEVerifier, generatePKCEChallenge, supportsLocalStorage } from './lib/helpers';\nimport localStorageAdapter from './lib/local-storage';\nimport { polyfillGlobalThis } from './lib/polyfills';\npolyfillGlobalThis(); // Make \"globalThis\" available\nvar DEFAULT_OPTIONS = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit'\n};\n/** Current session will be checked for refresh at this interval. */\nvar AUTO_REFRESH_TICK_DURATION = 30 * 1000;\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nvar AUTO_REFRESH_TICK_THRESHOLD = 3;\nvar GoTrueClient = /*#__PURE__*/function () {\n  /**\n   * Create a new client for use in the browser.\n   */\n  function GoTrueClient(options) {\n    var _this = this;\n    _classCallCheck(this, GoTrueClient);\n    var _a;\n    this.stateChangeEmitters = new Map();\n    this.autoRefreshTicker = null;\n    this.visibilityChangedCallback = null;\n    this.refreshingDeferred = null;\n    /**\n     * Keeps track of the async client initialization.\n     * When null or not yet resolved the auth state is `unknown`\n     * Once resolved the the auth state is known and it's save to call any further client methods.\n     * Keep extra care to never reject or throw uncaught errors\n     */\n    this.initializePromise = null;\n    this.detectSessionInUrl = true;\n    /**\n     * Used to broadcast state change events to other tabs listening.\n     */\n    this.broadcastChannel = null;\n    var settings = Object.assign(Object.assign({}, DEFAULT_OPTIONS), options);\n    this.inMemorySession = null;\n    this.storageKey = settings.storageKey;\n    this.autoRefreshToken = settings.autoRefreshToken;\n    this.persistSession = settings.persistSession;\n    this.storage = settings.storage || localStorageAdapter;\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch\n    });\n    this.url = settings.url;\n    this.headers = settings.headers;\n    this.fetch = resolveFetch(settings.fetch);\n    this.detectSessionInUrl = settings.detectSessionInUrl;\n    this.flowType = settings.flowType;\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this)\n    };\n    if (this.persistSession && this.storage === localStorageAdapter && !supportsLocalStorage()) {\n      console.warn(\"No storage option exists to persist the session, which may result in unexpected behavior when using auth.\\n        If you want to set persistSession to true, please provide a storage option or you may set persistSession to false to disable this warning.\");\n    }\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey);\n      } catch (e) {\n        console.error('Failed to create a new BroadcastChannel, multi-tab state changes will not be available', e);\n      }\n      (_a = this.broadcastChannel) === null || _a === void 0 ? void 0 : _a.addEventListener('message', function (event) {\n        return __awaiter(_this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n          return _regeneratorRuntime().wrap(function _callee$(_context) {\n            while (1) switch (_context.prev = _context.next) {\n              case 0:\n                _context.next = 2;\n                return this._notifyAllSubscribers(event.data.event, event.data.session, false);\n              case 2:\n              case \"end\":\n                return _context.stop();\n            }\n          }, _callee, this);\n        }));\n      });\n    }\n    this.initialize();\n  }\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  _createClass(GoTrueClient, [{\n    key: \"initialize\",\n    value: function initialize() {\n      if (!this.initializePromise) {\n        this.initializePromise = this._initialize();\n      }\n      return this.initializePromise;\n    }\n    /**\n     * IMPORTANT:\n     * 1. Never throw in this method, as it is called from the constructor\n     * 2. Never return a session from this method as it would be cached over\n     *    the whole lifetime of the client\n     */\n  }, {\n    key: \"_initialize\",\n    value: function _initialize() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var _this2 = this;\n        var isPKCEFlow, _yield$this$_getSessi, data, error, session, redirectType;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              if (!this.initializePromise) {\n                _context3.next = 2;\n                break;\n              }\n              return _context3.abrupt(\"return\", this.initializePromise);\n            case 2:\n              _context3.prev = 2;\n              if (!isBrowser()) {\n                _context3.next = 9;\n                break;\n              }\n              _context3.next = 6;\n              return this._isPKCEFlow();\n            case 6:\n              _context3.t0 = _context3.sent;\n              _context3.next = 10;\n              break;\n            case 9:\n              _context3.t0 = false;\n            case 10:\n              isPKCEFlow = _context3.t0;\n              if (!(isPKCEFlow || this.detectSessionInUrl && this._isImplicitGrantFlow())) {\n                _context3.next = 26;\n                break;\n              }\n              _context3.next = 14;\n              return this._getSessionFromUrl(isPKCEFlow);\n            case 14:\n              _yield$this$_getSessi = _context3.sent;\n              data = _yield$this$_getSessi.data;\n              error = _yield$this$_getSessi.error;\n              if (!error) {\n                _context3.next = 21;\n                break;\n              }\n              _context3.next = 20;\n              return this._removeSession();\n            case 20:\n              return _context3.abrupt(\"return\", {\n                error: error\n              });\n            case 21:\n              session = data.session, redirectType = data.redirectType;\n              _context3.next = 24;\n              return this._saveSession(session);\n            case 24:\n              setTimeout(function () {\n                return __awaiter(_this2, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n                  return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n                    while (1) switch (_context2.prev = _context2.next) {\n                      case 0:\n                        if (!(redirectType === 'recovery')) {\n                          _context2.next = 5;\n                          break;\n                        }\n                        _context2.next = 3;\n                        return this._notifyAllSubscribers('PASSWORD_RECOVERY', session);\n                      case 3:\n                        _context2.next = 7;\n                        break;\n                      case 5:\n                        _context2.next = 7;\n                        return this._notifyAllSubscribers('SIGNED_IN', session);\n                      case 7:\n                      case \"end\":\n                        return _context2.stop();\n                    }\n                  }, _callee2, this);\n                }));\n              }, 0);\n              return _context3.abrupt(\"return\", {\n                error: null\n              });\n            case 26:\n              _context3.next = 28;\n              return this._recoverAndRefresh();\n            case 28:\n              return _context3.abrupt(\"return\", {\n                error: null\n              });\n            case 31:\n              _context3.prev = 31;\n              _context3.t1 = _context3[\"catch\"](2);\n              if (!isAuthError(_context3.t1)) {\n                _context3.next = 35;\n                break;\n              }\n              return _context3.abrupt(\"return\", {\n                error: _context3.t1\n              });\n            case 35:\n              return _context3.abrupt(\"return\", {\n                error: new AuthUnknownError('Unexpected error during initialization', _context3.t1)\n              });\n            case 36:\n              _context3.prev = 36;\n              _context3.next = 39;\n              return this._handleVisibilityChange();\n            case 39:\n              return _context3.finish(36);\n            case 40:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this, [[2, 31, 36, 40]]);\n      }));\n    }\n    /**\n     * Creates a new user.\n     *\n     * Be aware that if a user account exists in the system you may get back an\n     * error message that attempts to hide this information from the user.\n     * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n     *\n     * @returns A logged-in session if the server has \"autoconfirm\" ON\n     * @returns A user if the server has \"autoconfirm\" OFF\n     */\n  }, {\n    key: \"signUp\",\n    value: function signUp(credentials) {\n      var _a, _b, _c;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        var res, email, password, options, codeChallenge, codeChallengeMethod, codeVerifier, phone, _password, _options, _res, data, error, session, user;\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.prev = 0;\n              _context4.next = 3;\n              return this._removeSession();\n            case 3:\n              if (!('email' in credentials)) {\n                _context4.next = 20;\n                break;\n              }\n              email = credentials.email, password = credentials.password, options = credentials.options;\n              codeChallenge = null;\n              codeChallengeMethod = null;\n              if (!(this.flowType === 'pkce')) {\n                _context4.next = 15;\n                break;\n              }\n              codeVerifier = generatePKCEVerifier();\n              _context4.next = 11;\n              return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n            case 11:\n              _context4.next = 13;\n              return generatePKCEChallenge(codeVerifier);\n            case 13:\n              codeChallenge = _context4.sent;\n              codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n            case 15:\n              _context4.next = 17;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                headers: this.headers,\n                redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                body: {\n                  email: email,\n                  password: password,\n                  data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                  gotrue_meta_security: {\n                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                  },\n                  code_challenge: codeChallenge,\n                  code_challenge_method: codeChallengeMethod\n                },\n                xform: _sessionResponse\n              });\n            case 17:\n              res = _context4.sent;\n              _context4.next = 28;\n              break;\n            case 20:\n              if (!('phone' in credentials)) {\n                _context4.next = 27;\n                break;\n              }\n              phone = credentials.phone, _password = credentials.password, _options = credentials.options;\n              _context4.next = 24;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/signup\"), {\n                headers: this.headers,\n                body: {\n                  phone: phone,\n                  password: _password,\n                  data: (_b = _options === null || _options === void 0 ? void 0 : _options.data) !== null && _b !== void 0 ? _b : {},\n                  channel: (_c = _options === null || _options === void 0 ? void 0 : _options.channel) !== null && _c !== void 0 ? _c : 'sms',\n                  gotrue_meta_security: {\n                    captcha_token: _options === null || _options === void 0 ? void 0 : _options.captchaToken\n                  }\n                },\n                xform: _sessionResponse\n              });\n            case 24:\n              res = _context4.sent;\n              _context4.next = 28;\n              break;\n            case 27:\n              throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n            case 28:\n              _res = res, data = _res.data, error = _res.error;\n              if (!(error || !data)) {\n                _context4.next = 31;\n                break;\n              }\n              return _context4.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 31:\n              session = data.session;\n              user = data.user;\n              if (!data.session) {\n                _context4.next = 38;\n                break;\n              }\n              _context4.next = 36;\n              return this._saveSession(data.session);\n            case 36:\n              _context4.next = 38;\n              return this._notifyAllSubscribers('SIGNED_IN', session);\n            case 38:\n              return _context4.abrupt(\"return\", {\n                data: {\n                  user: user,\n                  session: session\n                },\n                error: null\n              });\n            case 41:\n              _context4.prev = 41;\n              _context4.t0 = _context4[\"catch\"](0);\n              if (!isAuthError(_context4.t0)) {\n                _context4.next = 45;\n                break;\n              }\n              return _context4.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context4.t0\n              });\n            case 45:\n              throw _context4.t0;\n            case 46:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4, this, [[0, 41]]);\n      }));\n    }\n    /**\n     * Log in an existing user with an email and password or phone and password.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or that the\n     * email/phone and password combination is wrong or that the account can only\n     * be accessed via social login.\n     */\n  }, {\n    key: \"signInWithPassword\",\n    value: function signInWithPassword(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee5() {\n        var res, email, password, options, phone, _password2, _options2, _res2, data, error;\n        return _regeneratorRuntime().wrap(function _callee5$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.prev = 0;\n              _context5.next = 3;\n              return this._removeSession();\n            case 3:\n              if (!('email' in credentials)) {\n                _context5.next = 10;\n                break;\n              }\n              email = credentials.email, password = credentials.password, options = credentials.options;\n              _context5.next = 7;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                headers: this.headers,\n                body: {\n                  email: email,\n                  password: password,\n                  gotrue_meta_security: {\n                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                  }\n                },\n                xform: _sessionResponse\n              });\n            case 7:\n              res = _context5.sent;\n              _context5.next = 18;\n              break;\n            case 10:\n              if (!('phone' in credentials)) {\n                _context5.next = 17;\n                break;\n              }\n              phone = credentials.phone, _password2 = credentials.password, _options2 = credentials.options;\n              _context5.next = 14;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=password\"), {\n                headers: this.headers,\n                body: {\n                  phone: phone,\n                  password: _password2,\n                  gotrue_meta_security: {\n                    captcha_token: _options2 === null || _options2 === void 0 ? void 0 : _options2.captchaToken\n                  }\n                },\n                xform: _sessionResponse\n              });\n            case 14:\n              res = _context5.sent;\n              _context5.next = 18;\n              break;\n            case 17:\n              throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a password');\n            case 18:\n              _res2 = res, data = _res2.data, error = _res2.error;\n              if (!error) {\n                _context5.next = 23;\n                break;\n              }\n              return _context5.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 23:\n              if (!(!data || !data.session || !data.user)) {\n                _context5.next = 25;\n                break;\n              }\n              return _context5.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: new AuthInvalidTokenResponseError()\n              });\n            case 25:\n              if (!data.session) {\n                _context5.next = 30;\n                break;\n              }\n              _context5.next = 28;\n              return this._saveSession(data.session);\n            case 28:\n              _context5.next = 30;\n              return this._notifyAllSubscribers('SIGNED_IN', data.session);\n            case 30:\n              return _context5.abrupt(\"return\", {\n                data: {\n                  user: data.user,\n                  session: data.session\n                },\n                error: error\n              });\n            case 33:\n              _context5.prev = 33;\n              _context5.t0 = _context5[\"catch\"](0);\n              if (!isAuthError(_context5.t0)) {\n                _context5.next = 37;\n                break;\n              }\n              return _context5.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context5.t0\n              });\n            case 37:\n              throw _context5.t0;\n            case 38:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee5, this, [[0, 33]]);\n      }));\n    }\n    /**\n     * Log in an existing user via a third-party provider.\n     * This method supports the PKCE flow.\n     */\n  }, {\n    key: \"signInWithOAuth\",\n    value: function signInWithOAuth(credentials) {\n      var _a, _b, _c, _d;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee6() {\n        return _regeneratorRuntime().wrap(function _callee6$(_context6) {\n          while (1) switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this._removeSession();\n            case 2:\n              _context6.next = 4;\n              return this._handleProviderSignIn(credentials.provider, {\n                redirectTo: (_a = credentials.options) === null || _a === void 0 ? void 0 : _a.redirectTo,\n                scopes: (_b = credentials.options) === null || _b === void 0 ? void 0 : _b.scopes,\n                queryParams: (_c = credentials.options) === null || _c === void 0 ? void 0 : _c.queryParams,\n                skipBrowserRedirect: (_d = credentials.options) === null || _d === void 0 ? void 0 : _d.skipBrowserRedirect\n              });\n            case 4:\n              return _context6.abrupt(\"return\", _context6.sent);\n            case 5:\n            case \"end\":\n              return _context6.stop();\n          }\n        }, _callee6, this);\n      }));\n    }\n    /**\n     * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n     */\n  }, {\n    key: \"exchangeCodeForSession\",\n    value: function exchangeCodeForSession(authCode) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee7() {\n        var codeVerifier, _yield$_request, data, error;\n        return _regeneratorRuntime().wrap(function _callee7$(_context7) {\n          while (1) switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.next = 2;\n              return getItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            case 2:\n              codeVerifier = _context7.sent;\n              _context7.next = 5;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=pkce\"), {\n                headers: this.headers,\n                body: {\n                  auth_code: authCode,\n                  code_verifier: codeVerifier\n                },\n                xform: _sessionResponse\n              });\n            case 5:\n              _yield$_request = _context7.sent;\n              data = _yield$_request.data;\n              error = _yield$_request.error;\n              _context7.next = 10;\n              return removeItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            case 10:\n              if (!error) {\n                _context7.next = 14;\n                break;\n              }\n              return _context7.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 14:\n              if (!(!data || !data.session || !data.user)) {\n                _context7.next = 16;\n                break;\n              }\n              return _context7.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: new AuthInvalidTokenResponseError()\n              });\n            case 16:\n              if (!data.session) {\n                _context7.next = 21;\n                break;\n              }\n              _context7.next = 19;\n              return this._saveSession(data.session);\n            case 19:\n              _context7.next = 21;\n              return this._notifyAllSubscribers('SIGNED_IN', data.session);\n            case 21:\n              return _context7.abrupt(\"return\", {\n                data: data,\n                error: error\n              });\n            case 22:\n            case \"end\":\n              return _context7.stop();\n          }\n        }, _callee7, this);\n      }));\n    }\n    /**\n     * Allows signing in with an ID token issued by certain supported providers.\n     * The ID token is verified for validity and a new session is established.\n     *\n     * @experimental\n     */\n  }, {\n    key: \"signInWithIdToken\",\n    value: function signInWithIdToken(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee8() {\n        var options, provider, token, nonce, res, data, error;\n        return _regeneratorRuntime().wrap(function _callee8$(_context8) {\n          while (1) switch (_context8.prev = _context8.next) {\n            case 0:\n              _context8.next = 2;\n              return this._removeSession();\n            case 2:\n              _context8.prev = 2;\n              options = credentials.options, provider = credentials.provider, token = credentials.token, nonce = credentials.nonce;\n              _context8.next = 6;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=id_token\"), {\n                headers: this.headers,\n                body: {\n                  provider: provider,\n                  id_token: token,\n                  nonce: nonce,\n                  gotrue_meta_security: {\n                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                  }\n                },\n                xform: _sessionResponse\n              });\n            case 6:\n              res = _context8.sent;\n              data = res.data, error = res.error;\n              if (!error) {\n                _context8.next = 12;\n                break;\n              }\n              return _context8.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 12:\n              if (!(!data || !data.session || !data.user)) {\n                _context8.next = 14;\n                break;\n              }\n              return _context8.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: new AuthInvalidTokenResponseError()\n              });\n            case 14:\n              if (!data.session) {\n                _context8.next = 19;\n                break;\n              }\n              _context8.next = 17;\n              return this._saveSession(data.session);\n            case 17:\n              _context8.next = 19;\n              return this._notifyAllSubscribers('SIGNED_IN', data.session);\n            case 19:\n              return _context8.abrupt(\"return\", {\n                data: data,\n                error: error\n              });\n            case 22:\n              _context8.prev = 22;\n              _context8.t0 = _context8[\"catch\"](2);\n              if (!isAuthError(_context8.t0)) {\n                _context8.next = 26;\n                break;\n              }\n              return _context8.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context8.t0\n              });\n            case 26:\n              throw _context8.t0;\n            case 27:\n            case \"end\":\n              return _context8.stop();\n          }\n        }, _callee8, this, [[2, 22]]);\n      }));\n    }\n    /**\n     * Log in a user using magiclink or a one-time password (OTP).\n     *\n     * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n     * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n     * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n     *\n     * Be aware that you may get back an error message that will not distinguish\n     * between the cases where the account does not exist or, that the account\n     * can only be accessed via social login.\n     *\n     * Do note that you will need to configure a Whatsapp sender on Twilio\n     * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n     * channel is not supported on other providers\n     * at this time.\n     * This method supports PKCE when an email is passed.\n     */\n  }, {\n    key: \"signInWithOtp\",\n    value: function signInWithOtp(credentials) {\n      var _a, _b, _c, _d, _e;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee9() {\n        var email, options, codeChallenge, codeChallengeMethod, codeVerifier, _yield$_request2, error, phone, _options3, _yield$_request3, data, _error;\n        return _regeneratorRuntime().wrap(function _callee9$(_context9) {\n          while (1) switch (_context9.prev = _context9.next) {\n            case 0:\n              _context9.prev = 0;\n              _context9.next = 3;\n              return this._removeSession();\n            case 3:\n              if (!('email' in credentials)) {\n                _context9.next = 20;\n                break;\n              }\n              email = credentials.email, options = credentials.options;\n              codeChallenge = null;\n              codeChallengeMethod = null;\n              if (!(this.flowType === 'pkce')) {\n                _context9.next = 15;\n                break;\n              }\n              codeVerifier = generatePKCEVerifier();\n              _context9.next = 11;\n              return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n            case 11:\n              _context9.next = 13;\n              return generatePKCEChallenge(codeVerifier);\n            case 13:\n              codeChallenge = _context9.sent;\n              codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n            case 15:\n              _context9.next = 17;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                headers: this.headers,\n                body: {\n                  email: email,\n                  data: (_a = options === null || options === void 0 ? void 0 : options.data) !== null && _a !== void 0 ? _a : {},\n                  create_user: (_b = options === null || options === void 0 ? void 0 : options.shouldCreateUser) !== null && _b !== void 0 ? _b : true,\n                  gotrue_meta_security: {\n                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                  },\n                  code_challenge: codeChallenge,\n                  code_challenge_method: codeChallengeMethod\n                },\n                redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo\n              });\n            case 17:\n              _yield$_request2 = _context9.sent;\n              error = _yield$_request2.error;\n              return _context9.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 20:\n              if (!('phone' in credentials)) {\n                _context9.next = 28;\n                break;\n              }\n              phone = credentials.phone, _options3 = credentials.options;\n              _context9.next = 24;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/otp\"), {\n                headers: this.headers,\n                body: {\n                  phone: phone,\n                  data: (_c = _options3 === null || _options3 === void 0 ? void 0 : _options3.data) !== null && _c !== void 0 ? _c : {},\n                  create_user: (_d = _options3 === null || _options3 === void 0 ? void 0 : _options3.shouldCreateUser) !== null && _d !== void 0 ? _d : true,\n                  gotrue_meta_security: {\n                    captcha_token: _options3 === null || _options3 === void 0 ? void 0 : _options3.captchaToken\n                  },\n                  channel: (_e = _options3 === null || _options3 === void 0 ? void 0 : _options3.channel) !== null && _e !== void 0 ? _e : 'sms'\n                }\n              });\n            case 24:\n              _yield$_request3 = _context9.sent;\n              data = _yield$_request3.data;\n              _error = _yield$_request3.error;\n              return _context9.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null,\n                  messageId: data === null || data === void 0 ? void 0 : data.message_id\n                },\n                error: _error\n              });\n            case 28:\n              throw new AuthInvalidCredentialsError('You must provide either an email or phone number.');\n            case 31:\n              _context9.prev = 31;\n              _context9.t0 = _context9[\"catch\"](0);\n              if (!isAuthError(_context9.t0)) {\n                _context9.next = 35;\n                break;\n              }\n              return _context9.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context9.t0\n              });\n            case 35:\n              throw _context9.t0;\n            case 36:\n            case \"end\":\n              return _context9.stop();\n          }\n        }, _callee9, this, [[0, 31]]);\n      }));\n    }\n    /**\n     * Log in a user given a User supplied OTP received via mobile.\n     */\n  }, {\n    key: \"verifyOtp\",\n    value: function verifyOtp(params) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee10() {\n        var _yield$_request4, data, error, session, user;\n        return _regeneratorRuntime().wrap(function _callee10$(_context10) {\n          while (1) switch (_context10.prev = _context10.next) {\n            case 0:\n              _context10.prev = 0;\n              if (!(params.type !== 'email_change' && params.type !== 'phone_change')) {\n                _context10.next = 4;\n                break;\n              }\n              _context10.next = 4;\n              return this._removeSession();\n            case 4:\n              _context10.next = 6;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/verify\"), {\n                headers: this.headers,\n                body: Object.assign(Object.assign({}, params), {\n                  gotrue_meta_security: {\n                    captcha_token: (_a = params.options) === null || _a === void 0 ? void 0 : _a.captchaToken\n                  }\n                }),\n                redirectTo: (_b = params.options) === null || _b === void 0 ? void 0 : _b.redirectTo,\n                xform: _sessionResponse\n              });\n            case 6:\n              _yield$_request4 = _context10.sent;\n              data = _yield$_request4.data;\n              error = _yield$_request4.error;\n              if (!error) {\n                _context10.next = 11;\n                break;\n              }\n              throw error;\n            case 11:\n              if (data) {\n                _context10.next = 13;\n                break;\n              }\n              throw new Error('An error occurred on token verification.');\n            case 13:\n              session = data.session;\n              user = data.user;\n              if (!(session === null || session === void 0 ? void 0 : session.access_token)) {\n                _context10.next = 20;\n                break;\n              }\n              _context10.next = 18;\n              return this._saveSession(session);\n            case 18:\n              _context10.next = 20;\n              return this._notifyAllSubscribers('SIGNED_IN', session);\n            case 20:\n              return _context10.abrupt(\"return\", {\n                data: {\n                  user: user,\n                  session: session\n                },\n                error: null\n              });\n            case 23:\n              _context10.prev = 23;\n              _context10.t0 = _context10[\"catch\"](0);\n              if (!isAuthError(_context10.t0)) {\n                _context10.next = 27;\n                break;\n              }\n              return _context10.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context10.t0\n              });\n            case 27:\n              throw _context10.t0;\n            case 28:\n            case \"end\":\n              return _context10.stop();\n          }\n        }, _callee10, this, [[0, 23]]);\n      }));\n    }\n    /**\n     * Attempts a single-sign on using an enterprise Identity Provider. A\n     * successful SSO attempt will redirect the current page to the identity\n     * provider authorization page. The redirect URL is implementation and SSO\n     * protocol specific.\n     *\n     * You can use it by providing a SSO domain. Typically you can extract this\n     * domain by asking users for their email address. If this domain is\n     * registered on the Auth instance the redirect will use that organization's\n     * currently active SSO Identity Provider for the login.\n     *\n     * If you have built an organization-specific login page, you can use the\n     * organization's SSO Identity Provider UUID directly instead.\n     */\n  }, {\n    key: \"signInWithSSO\",\n    value: function signInWithSSO(params) {\n      var _a, _b, _c;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee11() {\n        return _regeneratorRuntime().wrap(function _callee11$(_context11) {\n          while (1) switch (_context11.prev = _context11.next) {\n            case 0:\n              _context11.prev = 0;\n              _context11.next = 3;\n              return this._removeSession();\n            case 3:\n              _context11.next = 5;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/sso\"), {\n                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, 'providerId' in params ? {\n                  provider_id: params.providerId\n                } : null), 'domain' in params ? {\n                  domain: params.domain\n                } : null), {\n                  redirect_to: (_b = (_a = params.options) === null || _a === void 0 ? void 0 : _a.redirectTo) !== null && _b !== void 0 ? _b : undefined\n                }), ((_c = params === null || params === void 0 ? void 0 : params.options) === null || _c === void 0 ? void 0 : _c.captchaToken) ? {\n                  gotrue_meta_security: {\n                    captcha_token: params.options.captchaToken\n                  }\n                } : null), {\n                  skip_http_redirect: true\n                }),\n                headers: this.headers,\n                xform: _ssoResponse\n              });\n            case 5:\n              return _context11.abrupt(\"return\", _context11.sent);\n            case 8:\n              _context11.prev = 8;\n              _context11.t0 = _context11[\"catch\"](0);\n              if (!isAuthError(_context11.t0)) {\n                _context11.next = 12;\n                break;\n              }\n              return _context11.abrupt(\"return\", {\n                data: null,\n                error: _context11.t0\n              });\n            case 12:\n              throw _context11.t0;\n            case 13:\n            case \"end\":\n              return _context11.stop();\n          }\n        }, _callee11, this, [[0, 8]]);\n      }));\n    }\n    /**\n     * Sends a reauthentication OTP to the user's email or phone number.\n     * Requires the user to be signed-in.\n     */\n  }, {\n    key: \"reauthenticate\",\n    value: function reauthenticate() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee12() {\n        var _yield$this$getSessio, session, sessionError, _yield$_request5, error;\n        return _regeneratorRuntime().wrap(function _callee12$(_context12) {\n          while (1) switch (_context12.prev = _context12.next) {\n            case 0:\n              _context12.prev = 0;\n              _context12.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio = _context12.sent;\n              session = _yield$this$getSessio.data.session;\n              sessionError = _yield$this$getSessio.error;\n              if (!sessionError) {\n                _context12.next = 8;\n                break;\n              }\n              throw sessionError;\n            case 8:\n              if (session) {\n                _context12.next = 10;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 10:\n              _context12.next = 12;\n              return _request(this.fetch, 'GET', \"\".concat(this.url, \"/reauthenticate\"), {\n                headers: this.headers,\n                jwt: session.access_token\n              });\n            case 12:\n              _yield$_request5 = _context12.sent;\n              error = _yield$_request5.error;\n              return _context12.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 17:\n              _context12.prev = 17;\n              _context12.t0 = _context12[\"catch\"](0);\n              if (!isAuthError(_context12.t0)) {\n                _context12.next = 21;\n                break;\n              }\n              return _context12.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context12.t0\n              });\n            case 21:\n              throw _context12.t0;\n            case 22:\n            case \"end\":\n              return _context12.stop();\n          }\n        }, _callee12, this, [[0, 17]]);\n      }));\n    }\n    /**\n     * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n     */\n  }, {\n    key: \"resend\",\n    value: function resend(credentials) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee13() {\n        var endpoint, email, type, options, _yield$_request6, error, phone, _type, _options4, _yield$_request7, data, _error2;\n        return _regeneratorRuntime().wrap(function _callee13$(_context13) {\n          while (1) switch (_context13.prev = _context13.next) {\n            case 0:\n              _context13.prev = 0;\n              _context13.next = 3;\n              return this._removeSession();\n            case 3:\n              endpoint = \"\".concat(this.url, \"/resend\");\n              if (!('email' in credentials)) {\n                _context13.next = 13;\n                break;\n              }\n              email = credentials.email, type = credentials.type, options = credentials.options;\n              _context13.next = 8;\n              return _request(this.fetch, 'POST', endpoint, {\n                headers: this.headers,\n                body: {\n                  email: email,\n                  type: type,\n                  gotrue_meta_security: {\n                    captcha_token: options === null || options === void 0 ? void 0 : options.captchaToken\n                  }\n                }\n              });\n            case 8:\n              _yield$_request6 = _context13.sent;\n              error = _yield$_request6.error;\n              return _context13.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 13:\n              if (!('phone' in credentials)) {\n                _context13.next = 21;\n                break;\n              }\n              phone = credentials.phone, _type = credentials.type, _options4 = credentials.options;\n              _context13.next = 17;\n              return _request(this.fetch, 'POST', endpoint, {\n                headers: this.headers,\n                body: {\n                  phone: phone,\n                  type: _type,\n                  gotrue_meta_security: {\n                    captcha_token: _options4 === null || _options4 === void 0 ? void 0 : _options4.captchaToken\n                  }\n                }\n              });\n            case 17:\n              _yield$_request7 = _context13.sent;\n              data = _yield$_request7.data;\n              _error2 = _yield$_request7.error;\n              return _context13.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null,\n                  messageId: data === null || data === void 0 ? void 0 : data.message_id\n                },\n                error: _error2\n              });\n            case 21:\n              throw new AuthInvalidCredentialsError('You must provide either an email or phone number and a type');\n            case 24:\n              _context13.prev = 24;\n              _context13.t0 = _context13[\"catch\"](0);\n              if (!isAuthError(_context13.t0)) {\n                _context13.next = 28;\n                break;\n              }\n              return _context13.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context13.t0\n              });\n            case 28:\n              throw _context13.t0;\n            case 29:\n            case \"end\":\n              return _context13.stop();\n          }\n        }, _callee13, this, [[0, 24]]);\n      }));\n    }\n    /**\n     * Returns the session, refreshing it if necessary.\n     * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n     */\n  }, {\n    key: \"getSession\",\n    value: function getSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee14() {\n        var currentSession, maybeSession, hasExpired, _yield$this$_callRefr, session, error;\n        return _regeneratorRuntime().wrap(function _callee14$(_context14) {\n          while (1) switch (_context14.prev = _context14.next) {\n            case 0:\n              _context14.next = 2;\n              return this.initializePromise;\n            case 2:\n              currentSession = null;\n              if (!this.persistSession) {\n                _context14.next = 16;\n                break;\n              }\n              _context14.next = 6;\n              return getItemAsync(this.storage, this.storageKey);\n            case 6:\n              maybeSession = _context14.sent;\n              if (!(maybeSession !== null)) {\n                _context14.next = 14;\n                break;\n              }\n              if (!this._isValidSession(maybeSession)) {\n                _context14.next = 12;\n                break;\n              }\n              currentSession = maybeSession;\n              _context14.next = 14;\n              break;\n            case 12:\n              _context14.next = 14;\n              return this._removeSession();\n            case 14:\n              _context14.next = 17;\n              break;\n            case 16:\n              currentSession = this.inMemorySession;\n            case 17:\n              if (currentSession) {\n                _context14.next = 19;\n                break;\n              }\n              return _context14.abrupt(\"return\", {\n                data: {\n                  session: null\n                },\n                error: null\n              });\n            case 19:\n              hasExpired = currentSession.expires_at ? currentSession.expires_at <= Date.now() / 1000 : false;\n              if (hasExpired) {\n                _context14.next = 22;\n                break;\n              }\n              return _context14.abrupt(\"return\", {\n                data: {\n                  session: currentSession\n                },\n                error: null\n              });\n            case 22:\n              _context14.next = 24;\n              return this._callRefreshToken(currentSession.refresh_token);\n            case 24:\n              _yield$this$_callRefr = _context14.sent;\n              session = _yield$this$_callRefr.session;\n              error = _yield$this$_callRefr.error;\n              if (!error) {\n                _context14.next = 29;\n                break;\n              }\n              return _context14.abrupt(\"return\", {\n                data: {\n                  session: null\n                },\n                error: error\n              });\n            case 29:\n              return _context14.abrupt(\"return\", {\n                data: {\n                  session: session\n                },\n                error: null\n              });\n            case 30:\n            case \"end\":\n              return _context14.stop();\n          }\n        }, _callee14, this);\n      }));\n    }\n    /**\n     * Gets the current user details if there is an existing session.\n     * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n     */\n  }, {\n    key: \"getUser\",\n    value: function getUser(jwt) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee15() {\n        var _yield$this$getSessio2, data, error;\n        return _regeneratorRuntime().wrap(function _callee15$(_context15) {\n          while (1) switch (_context15.prev = _context15.next) {\n            case 0:\n              _context15.prev = 0;\n              if (jwt) {\n                _context15.next = 10;\n                break;\n              }\n              _context15.next = 4;\n              return this.getSession();\n            case 4:\n              _yield$this$getSessio2 = _context15.sent;\n              data = _yield$this$getSessio2.data;\n              error = _yield$this$getSessio2.error;\n              if (!error) {\n                _context15.next = 9;\n                break;\n              }\n              throw error;\n            case 9:\n              // Default to Authorization header if there is no existing session\n              jwt = (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : undefined;\n            case 10:\n              _context15.next = 12;\n              return _request(this.fetch, 'GET', \"\".concat(this.url, \"/user\"), {\n                headers: this.headers,\n                jwt: jwt,\n                xform: _userResponse\n              });\n            case 12:\n              return _context15.abrupt(\"return\", _context15.sent);\n            case 15:\n              _context15.prev = 15;\n              _context15.t0 = _context15[\"catch\"](0);\n              if (!isAuthError(_context15.t0)) {\n                _context15.next = 19;\n                break;\n              }\n              return _context15.abrupt(\"return\", {\n                data: {\n                  user: null\n                },\n                error: _context15.t0\n              });\n            case 19:\n              throw _context15.t0;\n            case 20:\n            case \"end\":\n              return _context15.stop();\n          }\n        }, _callee15, this, [[0, 15]]);\n      }));\n    }\n    /**\n     * Updates user data for a logged in user.\n     */\n  }, {\n    key: \"updateUser\",\n    value: function updateUser(attributes) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee16() {\n        var _yield$this$getSessio3, sessionData, sessionError, session, _yield$_request8, data, userError;\n        return _regeneratorRuntime().wrap(function _callee16$(_context16) {\n          while (1) switch (_context16.prev = _context16.next) {\n            case 0:\n              _context16.prev = 0;\n              _context16.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio3 = _context16.sent;\n              sessionData = _yield$this$getSessio3.data;\n              sessionError = _yield$this$getSessio3.error;\n              if (!sessionError) {\n                _context16.next = 8;\n                break;\n              }\n              throw sessionError;\n            case 8:\n              if (sessionData.session) {\n                _context16.next = 10;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 10:\n              session = sessionData.session;\n              _context16.next = 13;\n              return _request(this.fetch, 'PUT', \"\".concat(this.url, \"/user\"), {\n                headers: this.headers,\n                redirectTo: options === null || options === void 0 ? void 0 : options.emailRedirectTo,\n                body: attributes,\n                jwt: session.access_token,\n                xform: _userResponse\n              });\n            case 13:\n              _yield$_request8 = _context16.sent;\n              data = _yield$_request8.data;\n              userError = _yield$_request8.error;\n              if (!userError) {\n                _context16.next = 18;\n                break;\n              }\n              throw userError;\n            case 18:\n              session.user = data.user;\n              _context16.next = 21;\n              return this._saveSession(session);\n            case 21:\n              _context16.next = 23;\n              return this._notifyAllSubscribers('USER_UPDATED', session);\n            case 23:\n              return _context16.abrupt(\"return\", {\n                data: {\n                  user: session.user\n                },\n                error: null\n              });\n            case 26:\n              _context16.prev = 26;\n              _context16.t0 = _context16[\"catch\"](0);\n              if (!isAuthError(_context16.t0)) {\n                _context16.next = 30;\n                break;\n              }\n              return _context16.abrupt(\"return\", {\n                data: {\n                  user: null\n                },\n                error: _context16.t0\n              });\n            case 30:\n              throw _context16.t0;\n            case 31:\n            case \"end\":\n              return _context16.stop();\n          }\n        }, _callee16, this, [[0, 26]]);\n      }));\n    }\n    /**\n     * Decodes a JWT (without performing any validation).\n     */\n  }, {\n    key: \"_decodeJWT\",\n    value: function _decodeJWT(jwt) {\n      return decodeJWTPayload(jwt);\n    }\n    /**\n     * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n     * If the refresh token or access token in the current session is invalid, an error will be thrown.\n     * @param currentSession The current session that minimally contains an access token and refresh token.\n     */\n  }, {\n    key: \"setSession\",\n    value: function setSession(currentSession) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee17() {\n        var timeNow, expiresAt, hasExpired, session, payload, _yield$this$_callRefr2, refreshedSession, error, _yield$this$getUser, data, _error3;\n        return _regeneratorRuntime().wrap(function _callee17$(_context17) {\n          while (1) switch (_context17.prev = _context17.next) {\n            case 0:\n              _context17.prev = 0;\n              if (!(!currentSession.access_token || !currentSession.refresh_token)) {\n                _context17.next = 3;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 3:\n              timeNow = Date.now() / 1000;\n              expiresAt = timeNow;\n              hasExpired = true;\n              session = null;\n              payload = decodeJWTPayload(currentSession.access_token);\n              if (payload.exp) {\n                expiresAt = payload.exp;\n                hasExpired = expiresAt <= timeNow;\n              }\n              if (!hasExpired) {\n                _context17.next = 22;\n                break;\n              }\n              _context17.next = 12;\n              return this._callRefreshToken(currentSession.refresh_token);\n            case 12:\n              _yield$this$_callRefr2 = _context17.sent;\n              refreshedSession = _yield$this$_callRefr2.session;\n              error = _yield$this$_callRefr2.error;\n              if (!error) {\n                _context17.next = 17;\n                break;\n              }\n              return _context17.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 17:\n              if (refreshedSession) {\n                _context17.next = 19;\n                break;\n              }\n              return _context17.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: null\n              });\n            case 19:\n              session = refreshedSession;\n              _context17.next = 34;\n              break;\n            case 22:\n              _context17.next = 24;\n              return this.getUser(currentSession.access_token);\n            case 24:\n              _yield$this$getUser = _context17.sent;\n              data = _yield$this$getUser.data;\n              _error3 = _yield$this$getUser.error;\n              if (!_error3) {\n                _context17.next = 29;\n                break;\n              }\n              throw _error3;\n            case 29:\n              session = {\n                access_token: currentSession.access_token,\n                refresh_token: currentSession.refresh_token,\n                user: data.user,\n                token_type: 'bearer',\n                expires_in: expiresAt - timeNow,\n                expires_at: expiresAt\n              };\n              _context17.next = 32;\n              return this._saveSession(session);\n            case 32:\n              _context17.next = 34;\n              return this._notifyAllSubscribers('SIGNED_IN', session);\n            case 34:\n              return _context17.abrupt(\"return\", {\n                data: {\n                  user: session.user,\n                  session: session\n                },\n                error: null\n              });\n            case 37:\n              _context17.prev = 37;\n              _context17.t0 = _context17[\"catch\"](0);\n              if (!isAuthError(_context17.t0)) {\n                _context17.next = 41;\n                break;\n              }\n              return _context17.abrupt(\"return\", {\n                data: {\n                  session: null,\n                  user: null\n                },\n                error: _context17.t0\n              });\n            case 41:\n              throw _context17.t0;\n            case 42:\n            case \"end\":\n              return _context17.stop();\n          }\n        }, _callee17, this, [[0, 37]]);\n      }));\n    }\n    /**\n     * Returns a new session, regardless of expiry status.\n     * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n     * If the current session's refresh token is invalid, an error will be thrown.\n     * @param currentSession The current session. If passed in, it must contain a refresh token.\n     */\n  }, {\n    key: \"refreshSession\",\n    value: function refreshSession(currentSession) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee18() {\n        var _yield$this$getSessio4, data, _error4, _yield$this$_callRefr3, session, error;\n        return _regeneratorRuntime().wrap(function _callee18$(_context18) {\n          while (1) switch (_context18.prev = _context18.next) {\n            case 0:\n              _context18.prev = 0;\n              if (currentSession) {\n                _context18.next = 10;\n                break;\n              }\n              _context18.next = 4;\n              return this.getSession();\n            case 4:\n              _yield$this$getSessio4 = _context18.sent;\n              data = _yield$this$getSessio4.data;\n              _error4 = _yield$this$getSessio4.error;\n              if (!_error4) {\n                _context18.next = 9;\n                break;\n              }\n              throw _error4;\n            case 9:\n              currentSession = (_a = data.session) !== null && _a !== void 0 ? _a : undefined;\n            case 10:\n              if (currentSession === null || currentSession === void 0 ? void 0 : currentSession.refresh_token) {\n                _context18.next = 12;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 12:\n              _context18.next = 14;\n              return this._callRefreshToken(currentSession.refresh_token);\n            case 14:\n              _yield$this$_callRefr3 = _context18.sent;\n              session = _yield$this$_callRefr3.session;\n              error = _yield$this$_callRefr3.error;\n              if (!error) {\n                _context18.next = 19;\n                break;\n              }\n              return _context18.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: error\n              });\n            case 19:\n              if (session) {\n                _context18.next = 21;\n                break;\n              }\n              return _context18.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: null\n              });\n            case 21:\n              return _context18.abrupt(\"return\", {\n                data: {\n                  user: session.user,\n                  session: session\n                },\n                error: null\n              });\n            case 24:\n              _context18.prev = 24;\n              _context18.t0 = _context18[\"catch\"](0);\n              if (!isAuthError(_context18.t0)) {\n                _context18.next = 28;\n                break;\n              }\n              return _context18.abrupt(\"return\", {\n                data: {\n                  user: null,\n                  session: null\n                },\n                error: _context18.t0\n              });\n            case 28:\n              throw _context18.t0;\n            case 29:\n            case \"end\":\n              return _context18.stop();\n          }\n        }, _callee18, this, [[0, 24]]);\n      }));\n    }\n    /**\n     * Gets the session data from a URL string\n     */\n  }, {\n    key: \"_getSessionFromUrl\",\n    value: function _getSessionFromUrl(isPKCEFlow) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee19() {\n        var authCode, _yield$this$exchangeC, _data, _error5, url, error_description, error_code, _error6, provider_token, provider_refresh_token, access_token, expires_in, refresh_token, token_type, timeNow, expires_at, _yield$this$getUser2, data, error, user, session, redirectType;\n        return _regeneratorRuntime().wrap(function _callee19$(_context19) {\n          while (1) switch (_context19.prev = _context19.next) {\n            case 0:\n              _context19.prev = 0;\n              if (isBrowser()) {\n                _context19.next = 3;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No browser detected.');\n            case 3:\n              if (!(this.flowType === 'implicit' && !this._isImplicitGrantFlow())) {\n                _context19.next = 7;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.');\n            case 7:\n              if (!(this.flowType == 'pkce' && !isPKCEFlow)) {\n                _context19.next = 9;\n                break;\n              }\n              throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.');\n            case 9:\n              if (!isPKCEFlow) {\n                _context19.next = 26;\n                break;\n              }\n              authCode = getParameterByName('code');\n              if (authCode) {\n                _context19.next = 13;\n                break;\n              }\n              throw new AuthPKCEGrantCodeExchangeError('No code detected.');\n            case 13:\n              _context19.next = 15;\n              return this.exchangeCodeForSession(authCode);\n            case 15:\n              _yield$this$exchangeC = _context19.sent;\n              _data = _yield$this$exchangeC.data;\n              _error5 = _yield$this$exchangeC.error;\n              if (!_error5) {\n                _context19.next = 20;\n                break;\n              }\n              throw _error5;\n            case 20:\n              if (_data.session) {\n                _context19.next = 22;\n                break;\n              }\n              throw new AuthPKCEGrantCodeExchangeError('No session detected.');\n            case 22:\n              url = new URL(window.location.href);\n              url.searchParams.delete('code');\n              window.history.replaceState(window.history.state, '', url.toString());\n              return _context19.abrupt(\"return\", {\n                data: {\n                  session: _data.session,\n                  redirectType: null\n                },\n                error: null\n              });\n            case 26:\n              error_description = getParameterByName('error_description');\n              if (!error_description) {\n                _context19.next = 35;\n                break;\n              }\n              error_code = getParameterByName('error_code');\n              if (error_code) {\n                _context19.next = 31;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No error_code detected.');\n            case 31:\n              _error6 = getParameterByName('error');\n              if (_error6) {\n                _context19.next = 34;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No error detected.');\n            case 34:\n              throw new AuthImplicitGrantRedirectError(error_description, {\n                error: _error6,\n                code: error_code\n              });\n            case 35:\n              provider_token = getParameterByName('provider_token');\n              provider_refresh_token = getParameterByName('provider_refresh_token');\n              access_token = getParameterByName('access_token');\n              if (access_token) {\n                _context19.next = 40;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No access_token detected.');\n            case 40:\n              expires_in = getParameterByName('expires_in');\n              if (expires_in) {\n                _context19.next = 43;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No expires_in detected.');\n            case 43:\n              refresh_token = getParameterByName('refresh_token');\n              if (refresh_token) {\n                _context19.next = 46;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No refresh_token detected.');\n            case 46:\n              token_type = getParameterByName('token_type');\n              if (token_type) {\n                _context19.next = 49;\n                break;\n              }\n              throw new AuthImplicitGrantRedirectError('No token_type detected.');\n            case 49:\n              timeNow = Math.round(Date.now() / 1000);\n              expires_at = timeNow + parseInt(expires_in);\n              _context19.next = 53;\n              return this.getUser(access_token);\n            case 53:\n              _yield$this$getUser2 = _context19.sent;\n              data = _yield$this$getUser2.data;\n              error = _yield$this$getUser2.error;\n              if (!error) {\n                _context19.next = 58;\n                break;\n              }\n              throw error;\n            case 58:\n              user = data.user;\n              session = {\n                provider_token: provider_token,\n                provider_refresh_token: provider_refresh_token,\n                access_token: access_token,\n                expires_in: parseInt(expires_in),\n                expires_at: expires_at,\n                refresh_token: refresh_token,\n                token_type: token_type,\n                user: user\n              };\n              redirectType = getParameterByName('type'); // Remove tokens from URL\n              window.location.hash = '';\n              return _context19.abrupt(\"return\", {\n                data: {\n                  session: session,\n                  redirectType: redirectType\n                },\n                error: null\n              });\n            case 65:\n              _context19.prev = 65;\n              _context19.t0 = _context19[\"catch\"](0);\n              if (!isAuthError(_context19.t0)) {\n                _context19.next = 69;\n                break;\n              }\n              return _context19.abrupt(\"return\", {\n                data: {\n                  session: null,\n                  redirectType: null\n                },\n                error: _context19.t0\n              });\n            case 69:\n              throw _context19.t0;\n            case 70:\n            case \"end\":\n              return _context19.stop();\n          }\n        }, _callee19, this, [[0, 65]]);\n      }));\n    }\n    /**\n     * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n     */\n  }, {\n    key: \"_isImplicitGrantFlow\",\n    value: function _isImplicitGrantFlow() {\n      return isBrowser() && (Boolean(getParameterByName('access_token')) || Boolean(getParameterByName('error_description')));\n    }\n    /**\n     * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n     */\n  }, {\n    key: \"_isPKCEFlow\",\n    value: function _isPKCEFlow() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee20() {\n        var currentStorageContent;\n        return _regeneratorRuntime().wrap(function _callee20$(_context20) {\n          while (1) switch (_context20.prev = _context20.next) {\n            case 0:\n              _context20.next = 2;\n              return getItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            case 2:\n              currentStorageContent = _context20.sent;\n              return _context20.abrupt(\"return\", Boolean(getParameterByName('code')) && Boolean(currentStorageContent));\n            case 4:\n            case \"end\":\n              return _context20.stop();\n          }\n        }, _callee20, this);\n      }));\n    }\n    /**\n     * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n     * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n     *\n     * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n     * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n     */\n  }, {\n    key: \"signOut\",\n    value: function signOut() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee21() {\n        var _yield$this$getSessio5, data, sessionError, accessToken, _yield$this$admin$sig, error;\n        return _regeneratorRuntime().wrap(function _callee21$(_context21) {\n          while (1) switch (_context21.prev = _context21.next) {\n            case 0:\n              _context21.next = 2;\n              return this.getSession();\n            case 2:\n              _yield$this$getSessio5 = _context21.sent;\n              data = _yield$this$getSessio5.data;\n              sessionError = _yield$this$getSessio5.error;\n              if (!sessionError) {\n                _context21.next = 7;\n                break;\n              }\n              return _context21.abrupt(\"return\", {\n                error: sessionError\n              });\n            case 7:\n              accessToken = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token;\n              if (!accessToken) {\n                _context21.next = 16;\n                break;\n              }\n              _context21.next = 11;\n              return this.admin.signOut(accessToken);\n            case 11:\n              _yield$this$admin$sig = _context21.sent;\n              error = _yield$this$admin$sig.error;\n              if (!error) {\n                _context21.next = 16;\n                break;\n              }\n              if (isAuthApiError(error) && (error.status === 404 || error.status === 401)) {\n                _context21.next = 16;\n                break;\n              }\n              return _context21.abrupt(\"return\", {\n                error: error\n              });\n            case 16:\n              _context21.next = 18;\n              return this._removeSession();\n            case 18:\n              _context21.next = 20;\n              return removeItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"));\n            case 20:\n              _context21.next = 22;\n              return this._notifyAllSubscribers('SIGNED_OUT', null);\n            case 22:\n              return _context21.abrupt(\"return\", {\n                error: null\n              });\n            case 23:\n            case \"end\":\n              return _context21.stop();\n          }\n        }, _callee21, this);\n      }));\n    }\n    /**\n     * Receive a notification every time an auth event happens.\n     * @param callback A callback function to be invoked when an auth event happens.\n     */\n  }, {\n    key: \"onAuthStateChange\",\n    value: function onAuthStateChange(callback) {\n      var _this3 = this;\n      var id = uuid();\n      var subscription = {\n        id: id,\n        callback: callback,\n        unsubscribe: function unsubscribe() {\n          _this3.stateChangeEmitters.delete(id);\n        }\n      };\n      this.stateChangeEmitters.set(id, subscription);\n      this.emitInitialSession(id);\n      return {\n        data: {\n          subscription: subscription\n        }\n      };\n    }\n  }, {\n    key: \"emitInitialSession\",\n    value: function emitInitialSession(id) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee22() {\n        var _yield$this$getSessio6, session, error;\n        return _regeneratorRuntime().wrap(function _callee22$(_context22) {\n          while (1) switch (_context22.prev = _context22.next) {\n            case 0:\n              _context22.prev = 0;\n              _context22.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio6 = _context22.sent;\n              session = _yield$this$getSessio6.data.session;\n              error = _yield$this$getSessio6.error;\n              if (!error) {\n                _context22.next = 8;\n                break;\n              }\n              throw error;\n            case 8:\n              _context22.next = 10;\n              return (_a = this.stateChangeEmitters.get(id)) === null || _a === void 0 ? void 0 : _a.callback('INITIAL_SESSION', session);\n            case 10:\n              _context22.next = 17;\n              break;\n            case 12:\n              _context22.prev = 12;\n              _context22.t0 = _context22[\"catch\"](0);\n              _context22.next = 16;\n              return (_b = this.stateChangeEmitters.get(id)) === null || _b === void 0 ? void 0 : _b.callback('INITIAL_SESSION', null);\n            case 16:\n              console.error(_context22.t0);\n            case 17:\n            case \"end\":\n              return _context22.stop();\n          }\n        }, _callee22, this, [[0, 12]]);\n      }));\n    }\n    /**\n     * Sends a password reset request to an email address.\n     * This method supports the PKCE flow.\n     * @param email The email address of the user.\n     * @param options.redirectTo The URL to send the user to after they click the password reset link.\n     * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n     */\n  }, {\n    key: \"resetPasswordForEmail\",\n    value: function resetPasswordForEmail(email) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee23() {\n        var codeChallenge, codeChallengeMethod, codeVerifier;\n        return _regeneratorRuntime().wrap(function _callee23$(_context23) {\n          while (1) switch (_context23.prev = _context23.next) {\n            case 0:\n              codeChallenge = null;\n              codeChallengeMethod = null;\n              if (!(this.flowType === 'pkce')) {\n                _context23.next = 10;\n                break;\n              }\n              codeVerifier = generatePKCEVerifier();\n              _context23.next = 6;\n              return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n            case 6:\n              _context23.next = 8;\n              return generatePKCEChallenge(codeVerifier);\n            case 8:\n              codeChallenge = _context23.sent;\n              codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n            case 10:\n              _context23.prev = 10;\n              _context23.next = 13;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/recover\"), {\n                body: {\n                  email: email,\n                  code_challenge: codeChallenge,\n                  code_challenge_method: codeChallengeMethod,\n                  gotrue_meta_security: {\n                    captcha_token: options.captchaToken\n                  }\n                },\n                headers: this.headers,\n                redirectTo: options.redirectTo\n              });\n            case 13:\n              return _context23.abrupt(\"return\", _context23.sent);\n            case 16:\n              _context23.prev = 16;\n              _context23.t0 = _context23[\"catch\"](10);\n              if (!isAuthError(_context23.t0)) {\n                _context23.next = 20;\n                break;\n              }\n              return _context23.abrupt(\"return\", {\n                data: null,\n                error: _context23.t0\n              });\n            case 20:\n              throw _context23.t0;\n            case 21:\n            case \"end\":\n              return _context23.stop();\n          }\n        }, _callee23, this, [[10, 16]]);\n      }));\n    }\n    /**\n     * Generates a new JWT.\n     * @param refreshToken A valid refresh token that was returned on login.\n     */\n  }, {\n    key: \"_refreshAccessToken\",\n    value: function _refreshAccessToken(refreshToken) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee25() {\n        var _this4 = this;\n        var startedAt;\n        return _regeneratorRuntime().wrap(function _callee25$(_context25) {\n          while (1) switch (_context25.prev = _context25.next) {\n            case 0:\n              _context25.prev = 0;\n              startedAt = Date.now(); // will attempt to refresh the token with exponential backoff\n              _context25.next = 4;\n              return retryable(function (attempt) {\n                return __awaiter(_this4, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee24() {\n                  return _regeneratorRuntime().wrap(function _callee24$(_context24) {\n                    while (1) switch (_context24.prev = _context24.next) {\n                      case 0:\n                        _context24.next = 2;\n                        return sleep(attempt * 200);\n                      case 2:\n                        _context24.next = 4;\n                        return _request(this.fetch, 'POST', \"\".concat(this.url, \"/token?grant_type=refresh_token\"), {\n                          body: {\n                            refresh_token: refreshToken\n                          },\n                          headers: this.headers,\n                          xform: _sessionResponse\n                        });\n                      case 4:\n                        return _context24.abrupt(\"return\", _context24.sent);\n                      case 5:\n                      case \"end\":\n                        return _context24.stop();\n                    }\n                  }, _callee24, this);\n                }));\n              }, function (attempt, _, result) {\n                return result && result.error && result.error instanceof AuthRetryableFetchError &&\n                // retryable only if the request can be sent before the backoff overflows the tick duration\n                Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION;\n              });\n            case 4:\n              return _context25.abrupt(\"return\", _context25.sent);\n            case 7:\n              _context25.prev = 7;\n              _context25.t0 = _context25[\"catch\"](0);\n              if (!isAuthError(_context25.t0)) {\n                _context25.next = 11;\n                break;\n              }\n              return _context25.abrupt(\"return\", {\n                data: {\n                  session: null,\n                  user: null\n                },\n                error: _context25.t0\n              });\n            case 11:\n              throw _context25.t0;\n            case 12:\n            case \"end\":\n              return _context25.stop();\n          }\n        }, _callee25, null, [[0, 7]]);\n      }));\n    }\n  }, {\n    key: \"_isValidSession\",\n    value: function _isValidSession(maybeSession) {\n      var isValidSession = typeof maybeSession === 'object' && maybeSession !== null && 'access_token' in maybeSession && 'refresh_token' in maybeSession && 'expires_at' in maybeSession;\n      return isValidSession;\n    }\n  }, {\n    key: \"_handleProviderSignIn\",\n    value: function _handleProviderSignIn(provider, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee26() {\n        var url;\n        return _regeneratorRuntime().wrap(function _callee26$(_context26) {\n          while (1) switch (_context26.prev = _context26.next) {\n            case 0:\n              _context26.next = 2;\n              return this._getUrlForProvider(provider, {\n                redirectTo: options.redirectTo,\n                scopes: options.scopes,\n                queryParams: options.queryParams\n              });\n            case 2:\n              url = _context26.sent;\n              // try to open on the browser\n              if (isBrowser() && !options.skipBrowserRedirect) {\n                window.location.assign(url);\n              }\n              return _context26.abrupt(\"return\", {\n                data: {\n                  provider: provider,\n                  url: url\n                },\n                error: null\n              });\n            case 5:\n            case \"end\":\n              return _context26.stop();\n          }\n        }, _callee26, this);\n      }));\n    }\n    /**\n     * Recovers the session from LocalStorage and refreshes\n     * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n     */\n  }, {\n    key: \"_recoverAndRefresh\",\n    value: function _recoverAndRefresh() {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee27() {\n        var currentSession, timeNow, _yield$this$_callRefr4, error;\n        return _regeneratorRuntime().wrap(function _callee27$(_context27) {\n          while (1) switch (_context27.prev = _context27.next) {\n            case 0:\n              _context27.prev = 0;\n              _context27.next = 3;\n              return getItemAsync(this.storage, this.storageKey);\n            case 3:\n              currentSession = _context27.sent;\n              if (this._isValidSession(currentSession)) {\n                _context27.next = 9;\n                break;\n              }\n              if (!(currentSession !== null)) {\n                _context27.next = 8;\n                break;\n              }\n              _context27.next = 8;\n              return this._removeSession();\n            case 8:\n              return _context27.abrupt(\"return\");\n            case 9:\n              timeNow = Math.round(Date.now() / 1000);\n              if (!(((_a = currentSession.expires_at) !== null && _a !== void 0 ? _a : Infinity) < timeNow + EXPIRY_MARGIN)) {\n                _context27.next = 22;\n                break;\n              }\n              if (!(this.autoRefreshToken && currentSession.refresh_token)) {\n                _context27.next = 20;\n                break;\n              }\n              _context27.next = 14;\n              return this._callRefreshToken(currentSession.refresh_token);\n            case 14:\n              _yield$this$_callRefr4 = _context27.sent;\n              error = _yield$this$_callRefr4.error;\n              if (!error) {\n                _context27.next = 20;\n                break;\n              }\n              console.log(error.message);\n              _context27.next = 20;\n              return this._removeSession();\n            case 20:\n              _context27.next = 27;\n              break;\n            case 22:\n              if (!this.persistSession) {\n                _context27.next = 25;\n                break;\n              }\n              _context27.next = 25;\n              return this._saveSession(currentSession);\n            case 25:\n              _context27.next = 27;\n              return this._notifyAllSubscribers('SIGNED_IN', currentSession);\n            case 27:\n              _context27.next = 33;\n              break;\n            case 29:\n              _context27.prev = 29;\n              _context27.t0 = _context27[\"catch\"](0);\n              console.error(_context27.t0);\n              return _context27.abrupt(\"return\");\n            case 33:\n            case \"end\":\n              return _context27.stop();\n          }\n        }, _callee27, this, [[0, 29]]);\n      }));\n    }\n  }, {\n    key: \"_callRefreshToken\",\n    value: function _callRefreshToken(refreshToken) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee28() {\n        var _yield$this$_refreshA, data, error, result, _result;\n        return _regeneratorRuntime().wrap(function _callee28$(_context28) {\n          while (1) switch (_context28.prev = _context28.next) {\n            case 0:\n              if (!this.refreshingDeferred) {\n                _context28.next = 2;\n                break;\n              }\n              return _context28.abrupt(\"return\", this.refreshingDeferred.promise);\n            case 2:\n              _context28.prev = 2;\n              this.refreshingDeferred = new Deferred();\n              if (refreshToken) {\n                _context28.next = 6;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 6:\n              _context28.next = 8;\n              return this._refreshAccessToken(refreshToken);\n            case 8:\n              _yield$this$_refreshA = _context28.sent;\n              data = _yield$this$_refreshA.data;\n              error = _yield$this$_refreshA.error;\n              if (!error) {\n                _context28.next = 13;\n                break;\n              }\n              throw error;\n            case 13:\n              if (data.session) {\n                _context28.next = 15;\n                break;\n              }\n              throw new AuthSessionMissingError();\n            case 15:\n              _context28.next = 17;\n              return this._saveSession(data.session);\n            case 17:\n              _context28.next = 19;\n              return this._notifyAllSubscribers('TOKEN_REFRESHED', data.session);\n            case 19:\n              result = {\n                session: data.session,\n                error: null\n              };\n              this.refreshingDeferred.resolve(result);\n              return _context28.abrupt(\"return\", result);\n            case 24:\n              _context28.prev = 24;\n              _context28.t0 = _context28[\"catch\"](2);\n              if (!isAuthError(_context28.t0)) {\n                _context28.next = 30;\n                break;\n              }\n              _result = {\n                session: null,\n                error: _context28.t0\n              };\n              (_a = this.refreshingDeferred) === null || _a === void 0 ? void 0 : _a.resolve(_result);\n              return _context28.abrupt(\"return\", _result);\n            case 30:\n              (_b = this.refreshingDeferred) === null || _b === void 0 ? void 0 : _b.reject(_context28.t0);\n              throw _context28.t0;\n            case 32:\n              _context28.prev = 32;\n              this.refreshingDeferred = null;\n              return _context28.finish(32);\n            case 35:\n            case \"end\":\n              return _context28.stop();\n          }\n        }, _callee28, this, [[2, 24, 32, 35]]);\n      }));\n    }\n  }, {\n    key: \"_notifyAllSubscribers\",\n    value: function _notifyAllSubscribers(event, session) {\n      var broadcast = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee30() {\n        var _this5 = this;\n        var errors, promises, i;\n        return _regeneratorRuntime().wrap(function _callee30$(_context30) {\n          while (1) switch (_context30.prev = _context30.next) {\n            case 0:\n              if (this.broadcastChannel && broadcast) {\n                this.broadcastChannel.postMessage({\n                  event: event,\n                  session: session\n                });\n              }\n              errors = [];\n              promises = Array.from(this.stateChangeEmitters.values()).map(function (x) {\n                return __awaiter(_this5, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee29() {\n                  return _regeneratorRuntime().wrap(function _callee29$(_context29) {\n                    while (1) switch (_context29.prev = _context29.next) {\n                      case 0:\n                        _context29.prev = 0;\n                        _context29.next = 3;\n                        return x.callback(event, session);\n                      case 3:\n                        _context29.next = 8;\n                        break;\n                      case 5:\n                        _context29.prev = 5;\n                        _context29.t0 = _context29[\"catch\"](0);\n                        errors.push(_context29.t0);\n                      case 8:\n                      case \"end\":\n                        return _context29.stop();\n                    }\n                  }, _callee29, null, [[0, 5]]);\n                }));\n              });\n              _context30.next = 5;\n              return Promise.all(promises);\n            case 5:\n              if (!(errors.length > 0)) {\n                _context30.next = 8;\n                break;\n              }\n              for (i = 0; i < errors.length; i += 1) {\n                console.error(errors[i]);\n              }\n              throw errors[0];\n            case 8:\n            case \"end\":\n              return _context30.stop();\n          }\n        }, _callee30, this);\n      }));\n    }\n    /**\n     * set currentSession and currentUser\n     * process to _startAutoRefreshToken if possible\n     */\n  }, {\n    key: \"_saveSession\",\n    value: function _saveSession(session) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee31() {\n        return _regeneratorRuntime().wrap(function _callee31$(_context31) {\n          while (1) switch (_context31.prev = _context31.next) {\n            case 0:\n              if (!this.persistSession) {\n                this.inMemorySession = session;\n              }\n              if (!(this.persistSession && session.expires_at)) {\n                _context31.next = 4;\n                break;\n              }\n              _context31.next = 4;\n              return this._persistSession(session);\n            case 4:\n            case \"end\":\n              return _context31.stop();\n          }\n        }, _callee31, this);\n      }));\n    }\n  }, {\n    key: \"_persistSession\",\n    value: function _persistSession(currentSession) {\n      return setItemAsync(this.storage, this.storageKey, currentSession);\n    }\n  }, {\n    key: \"_removeSession\",\n    value: function _removeSession() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee32() {\n        return _regeneratorRuntime().wrap(function _callee32$(_context32) {\n          while (1) switch (_context32.prev = _context32.next) {\n            case 0:\n              if (!this.persistSession) {\n                _context32.next = 5;\n                break;\n              }\n              _context32.next = 3;\n              return removeItemAsync(this.storage, this.storageKey);\n            case 3:\n              _context32.next = 6;\n              break;\n            case 5:\n              this.inMemorySession = null;\n            case 6:\n            case \"end\":\n              return _context32.stop();\n          }\n        }, _callee32, this);\n      }));\n    }\n    /**\n     * Removes any registered visibilitychange callback.\n     *\n     * {@see #startAutoRefresh}\n     * {@see #stopAutoRefresh}\n     */\n  }, {\n    key: \"_removeVisibilityChangedCallback\",\n    value: function _removeVisibilityChangedCallback() {\n      var callback = this.visibilityChangedCallback;\n      this.visibilityChangedCallback = null;\n      try {\n        if (callback && isBrowser() && (window === null || window === void 0 ? void 0 : window.removeEventListener)) {\n          window.removeEventListener('visibilitychange', callback);\n        }\n      } catch (e) {\n        console.error('removing visibilitychange callback failed', e);\n      }\n    }\n    /**\n     * This is the private implementation of {@link #startAutoRefresh}. Use this\n     * within the library.\n     */\n  }, {\n    key: \"_startAutoRefresh\",\n    value: function _startAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee33() {\n        var _this6 = this;\n        var ticker;\n        return _regeneratorRuntime().wrap(function _callee33$(_context33) {\n          while (1) switch (_context33.prev = _context33.next) {\n            case 0:\n              _context33.next = 2;\n              return this._stopAutoRefresh();\n            case 2:\n              ticker = setInterval(function () {\n                return _this6._autoRefreshTokenTick();\n              }, AUTO_REFRESH_TICK_DURATION);\n              this.autoRefreshTicker = ticker;\n              if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n                // ticker is a NodeJS Timeout object that has an `unref` method\n                // https://nodejs.org/api/timers.html#timeoutunref\n                // When auto refresh is used in NodeJS (like for testing) the\n                // `setInterval` is preventing the process from being marked as\n                // finished and tests run endlessly. This can be prevented by calling\n                // `unref()` on the returned object.\n                ticker.unref();\n                // @ts-ignore\n              } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n                // similar like for NodeJS, but with the Deno API\n                // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n                // @ts-ignore\n                Deno.unrefTimer(ticker);\n              }\n              // run the tick immediately\n              _context33.next = 7;\n              return this._autoRefreshTokenTick();\n            case 7:\n            case \"end\":\n              return _context33.stop();\n          }\n        }, _callee33, this);\n      }));\n    }\n    /**\n     * This is the private implementation of {@link #stopAutoRefresh}. Use this\n     * within the library.\n     */\n  }, {\n    key: \"_stopAutoRefresh\",\n    value: function _stopAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee34() {\n        var ticker;\n        return _regeneratorRuntime().wrap(function _callee34$(_context34) {\n          while (1) switch (_context34.prev = _context34.next) {\n            case 0:\n              ticker = this.autoRefreshTicker;\n              this.autoRefreshTicker = null;\n              if (ticker) {\n                clearInterval(ticker);\n              }\n            case 3:\n            case \"end\":\n              return _context34.stop();\n          }\n        }, _callee34, this);\n      }));\n    }\n    /**\n     * Starts an auto-refresh process in the background. The session is checked\n     * every few seconds. Close to the time of expiration a process is started to\n     * refresh the session. If refreshing fails it will be retried for as long as\n     * necessary.\n     *\n     * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n     * to call this function, it will be called for you.\n     *\n     * On browsers the refresh process works only when the tab/window is in the\n     * foreground to conserve resources as well as prevent race conditions and\n     * flooding auth with requests. If you call this method any managed\n     * visibility change callback will be removed and you must manage visibility\n     * changes on your own.\n     *\n     * On non-browser platforms the refresh process works *continuously* in the\n     * background, which may not be desirable. You should hook into your\n     * platform's foreground indication mechanism and call these methods\n     * appropriately to conserve resources.\n     *\n     * {@see #stopAutoRefresh}\n     */\n  }, {\n    key: \"startAutoRefresh\",\n    value: function startAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee35() {\n        return _regeneratorRuntime().wrap(function _callee35$(_context35) {\n          while (1) switch (_context35.prev = _context35.next) {\n            case 0:\n              this._removeVisibilityChangedCallback();\n              _context35.next = 3;\n              return this._startAutoRefresh();\n            case 3:\n            case \"end\":\n              return _context35.stop();\n          }\n        }, _callee35, this);\n      }));\n    }\n    /**\n     * Stops an active auto refresh process running in the background (if any).\n     *\n     * If you call this method any managed visibility change callback will be\n     * removed and you must manage visibility changes on your own.\n     *\n     * See {@link #startAutoRefresh} for more details.\n     */\n  }, {\n    key: \"stopAutoRefresh\",\n    value: function stopAutoRefresh() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee36() {\n        return _regeneratorRuntime().wrap(function _callee36$(_context36) {\n          while (1) switch (_context36.prev = _context36.next) {\n            case 0:\n              this._removeVisibilityChangedCallback();\n              _context36.next = 3;\n              return this._stopAutoRefresh();\n            case 3:\n            case \"end\":\n              return _context36.stop();\n          }\n        }, _callee36, this);\n      }));\n    }\n    /**\n     * Runs the auto refresh token tick.\n     */\n  }, {\n    key: \"_autoRefreshTokenTick\",\n    value: function _autoRefreshTokenTick() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee37() {\n        var now, _yield$this$getSessio7, session, expiresInTicks;\n        return _regeneratorRuntime().wrap(function _callee37$(_context37) {\n          while (1) switch (_context37.prev = _context37.next) {\n            case 0:\n              now = Date.now();\n              _context37.prev = 1;\n              _context37.next = 4;\n              return this.getSession();\n            case 4:\n              _yield$this$getSessio7 = _context37.sent;\n              session = _yield$this$getSessio7.data.session;\n              if (!(!session || !session.refresh_token || !session.expires_at)) {\n                _context37.next = 8;\n                break;\n              }\n              return _context37.abrupt(\"return\");\n            case 8:\n              // session will expire in this many ticks (or has already expired if <= 0)\n              expiresInTicks = Math.floor((session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION);\n              if (!(expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD)) {\n                _context37.next = 12;\n                break;\n              }\n              _context37.next = 12;\n              return this._callRefreshToken(session.refresh_token);\n            case 12:\n              _context37.next = 17;\n              break;\n            case 14:\n              _context37.prev = 14;\n              _context37.t0 = _context37[\"catch\"](1);\n              console.error('Auto refresh tick failed with error. This is likely a transient error.', _context37.t0);\n            case 17:\n            case \"end\":\n              return _context37.stop();\n          }\n        }, _callee37, this, [[1, 14]]);\n      }));\n    }\n    /**\n     * Registers callbacks on the browser / platform, which in-turn run\n     * algorithms when the browser window/tab are in foreground. On non-browser\n     * platforms it assumes always foreground.\n     */\n  }, {\n    key: \"_handleVisibilityChange\",\n    value: function _handleVisibilityChange() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee39() {\n        var _this7 = this;\n        return _regeneratorRuntime().wrap(function _callee39$(_context39) {\n          while (1) switch (_context39.prev = _context39.next) {\n            case 0:\n              if (!(!isBrowser() || !(window === null || window === void 0 ? void 0 : window.addEventListener))) {\n                _context39.next = 3;\n                break;\n              }\n              if (this.autoRefreshToken) {\n                // in non-browser environments the refresh token ticker runs always\n                this.startAutoRefresh();\n              }\n              return _context39.abrupt(\"return\", false);\n            case 3:\n              _context39.prev = 3;\n              this.visibilityChangedCallback = function () {\n                return __awaiter(_this7, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee38() {\n                  return _regeneratorRuntime().wrap(function _callee38$(_context38) {\n                    while (1) switch (_context38.prev = _context38.next) {\n                      case 0:\n                        _context38.next = 2;\n                        return this._onVisibilityChanged(false);\n                      case 2:\n                        return _context38.abrupt(\"return\", _context38.sent);\n                      case 3:\n                      case \"end\":\n                        return _context38.stop();\n                    }\n                  }, _callee38, this);\n                }));\n              };\n              window === null || window === void 0 ? void 0 : window.addEventListener('visibilitychange', this.visibilityChangedCallback);\n              // now immediately call the visbility changed callback to setup with the\n              // current visbility state\n              _context39.next = 8;\n              return this._onVisibilityChanged(true);\n            case 8:\n              _context39.next = 13;\n              break;\n            case 10:\n              _context39.prev = 10;\n              _context39.t0 = _context39[\"catch\"](3);\n              console.error('_handleVisibilityChange', _context39.t0);\n            case 13:\n            case \"end\":\n              return _context39.stop();\n          }\n        }, _callee39, this, [[3, 10]]);\n      }));\n    }\n    /**\n     * Callback registered with `window.addEventListener('visibilitychange')`.\n     */\n  }, {\n    key: \"_onVisibilityChanged\",\n    value: function _onVisibilityChanged(isInitial) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee40() {\n        return _regeneratorRuntime().wrap(function _callee40$(_context40) {\n          while (1) switch (_context40.prev = _context40.next) {\n            case 0:\n              if (!(document.visibilityState === 'visible')) {\n                _context40.next = 9;\n                break;\n              }\n              if (isInitial) {\n                _context40.next = 6;\n                break;\n              }\n              _context40.next = 4;\n              return this.initializePromise;\n            case 4:\n              _context40.next = 6;\n              return this._recoverAndRefresh();\n            case 6:\n              if (this.autoRefreshToken) {\n                // in browser environments the refresh token ticker runs only on focused tabs\n                // which prevents race conditions\n                this._startAutoRefresh();\n              }\n              _context40.next = 10;\n              break;\n            case 9:\n              if (document.visibilityState === 'hidden') {\n                if (this.autoRefreshToken) {\n                  this._stopAutoRefresh();\n                }\n              }\n            case 10:\n            case \"end\":\n              return _context40.stop();\n          }\n        }, _callee40, this);\n      }));\n    }\n    /**\n     * Generates the relevant login URL for a third-party provider.\n     * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n     * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n     * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n     */\n  }, {\n    key: \"_getUrlForProvider\",\n    value: function _getUrlForProvider(provider, options) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee41() {\n        var urlParams, codeVerifier, codeChallenge, codeChallengeMethod, flowParams, query;\n        return _regeneratorRuntime().wrap(function _callee41$(_context41) {\n          while (1) switch (_context41.prev = _context41.next) {\n            case 0:\n              urlParams = [\"provider=\".concat(encodeURIComponent(provider))];\n              if (options === null || options === void 0 ? void 0 : options.redirectTo) {\n                urlParams.push(\"redirect_to=\".concat(encodeURIComponent(options.redirectTo)));\n              }\n              if (options === null || options === void 0 ? void 0 : options.scopes) {\n                urlParams.push(\"scopes=\".concat(encodeURIComponent(options.scopes)));\n              }\n              if (!(this.flowType === 'pkce')) {\n                _context41.next = 13;\n                break;\n              }\n              codeVerifier = generatePKCEVerifier();\n              _context41.next = 7;\n              return setItemAsync(this.storage, \"\".concat(this.storageKey, \"-code-verifier\"), codeVerifier);\n            case 7:\n              _context41.next = 9;\n              return generatePKCEChallenge(codeVerifier);\n            case 9:\n              codeChallenge = _context41.sent;\n              codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256';\n              flowParams = new URLSearchParams({\n                code_challenge: \"\".concat(encodeURIComponent(codeChallenge)),\n                code_challenge_method: \"\".concat(encodeURIComponent(codeChallengeMethod))\n              });\n              urlParams.push(flowParams.toString());\n            case 13:\n              if (options === null || options === void 0 ? void 0 : options.queryParams) {\n                query = new URLSearchParams(options.queryParams);\n                urlParams.push(query.toString());\n              }\n              return _context41.abrupt(\"return\", \"\".concat(this.url, \"/authorize?\").concat(urlParams.join('&')));\n            case 15:\n            case \"end\":\n              return _context41.stop();\n          }\n        }, _callee41, this);\n      }));\n    }\n  }, {\n    key: \"_unenroll\",\n    value: function _unenroll(params) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee42() {\n        var _yield$this$getSessio8, sessionData, sessionError;\n        return _regeneratorRuntime().wrap(function _callee42$(_context42) {\n          while (1) switch (_context42.prev = _context42.next) {\n            case 0:\n              _context42.prev = 0;\n              _context42.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio8 = _context42.sent;\n              sessionData = _yield$this$getSessio8.data;\n              sessionError = _yield$this$getSessio8.error;\n              if (!sessionError) {\n                _context42.next = 8;\n                break;\n              }\n              return _context42.abrupt(\"return\", {\n                data: null,\n                error: sessionError\n              });\n            case 8:\n              _context42.next = 10;\n              return _request(this.fetch, 'DELETE', \"\".concat(this.url, \"/factors/\").concat(params.factorId), {\n                headers: this.headers,\n                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n              });\n            case 10:\n              return _context42.abrupt(\"return\", _context42.sent);\n            case 13:\n              _context42.prev = 13;\n              _context42.t0 = _context42[\"catch\"](0);\n              if (!isAuthError(_context42.t0)) {\n                _context42.next = 17;\n                break;\n              }\n              return _context42.abrupt(\"return\", {\n                data: null,\n                error: _context42.t0\n              });\n            case 17:\n              throw _context42.t0;\n            case 18:\n            case \"end\":\n              return _context42.stop();\n          }\n        }, _callee42, this, [[0, 13]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#enroll}\n     */\n  }, {\n    key: \"_enroll\",\n    value: function _enroll(params) {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee43() {\n        var _yield$this$getSessio9, sessionData, sessionError, _yield$_request9, data, error;\n        return _regeneratorRuntime().wrap(function _callee43$(_context43) {\n          while (1) switch (_context43.prev = _context43.next) {\n            case 0:\n              _context43.prev = 0;\n              _context43.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio9 = _context43.sent;\n              sessionData = _yield$this$getSessio9.data;\n              sessionError = _yield$this$getSessio9.error;\n              if (!sessionError) {\n                _context43.next = 8;\n                break;\n              }\n              return _context43.abrupt(\"return\", {\n                data: null,\n                error: sessionError\n              });\n            case 8:\n              _context43.next = 10;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors\"), {\n                body: {\n                  friendly_name: params.friendlyName,\n                  factor_type: params.factorType,\n                  issuer: params.issuer\n                },\n                headers: this.headers,\n                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n              });\n            case 10:\n              _yield$_request9 = _context43.sent;\n              data = _yield$_request9.data;\n              error = _yield$_request9.error;\n              if (!error) {\n                _context43.next = 15;\n                break;\n              }\n              return _context43.abrupt(\"return\", {\n                data: null,\n                error: error\n              });\n            case 15:\n              if ((_b = data === null || data === void 0 ? void 0 : data.totp) === null || _b === void 0 ? void 0 : _b.qr_code) {\n                data.totp.qr_code = \"data:image/svg+xml;utf-8,\".concat(data.totp.qr_code);\n              }\n              return _context43.abrupt(\"return\", {\n                data: data,\n                error: null\n              });\n            case 19:\n              _context43.prev = 19;\n              _context43.t0 = _context43[\"catch\"](0);\n              if (!isAuthError(_context43.t0)) {\n                _context43.next = 23;\n                break;\n              }\n              return _context43.abrupt(\"return\", {\n                data: null,\n                error: _context43.t0\n              });\n            case 23:\n              throw _context43.t0;\n            case 24:\n            case \"end\":\n              return _context43.stop();\n          }\n        }, _callee43, this, [[0, 19]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#verify}\n     */\n  }, {\n    key: \"_verify\",\n    value: function _verify(params) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee44() {\n        var _yield$this$getSessio10, sessionData, sessionError, _yield$_request10, data, error;\n        return _regeneratorRuntime().wrap(function _callee44$(_context44) {\n          while (1) switch (_context44.prev = _context44.next) {\n            case 0:\n              _context44.prev = 0;\n              _context44.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio10 = _context44.sent;\n              sessionData = _yield$this$getSessio10.data;\n              sessionError = _yield$this$getSessio10.error;\n              if (!sessionError) {\n                _context44.next = 8;\n                break;\n              }\n              return _context44.abrupt(\"return\", {\n                data: null,\n                error: sessionError\n              });\n            case 8:\n              _context44.next = 10;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/verify\"), {\n                body: {\n                  code: params.code,\n                  challenge_id: params.challengeId\n                },\n                headers: this.headers,\n                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n              });\n            case 10:\n              _yield$_request10 = _context44.sent;\n              data = _yield$_request10.data;\n              error = _yield$_request10.error;\n              if (!error) {\n                _context44.next = 15;\n                break;\n              }\n              return _context44.abrupt(\"return\", {\n                data: null,\n                error: error\n              });\n            case 15:\n              _context44.next = 17;\n              return this._saveSession(Object.assign({\n                expires_at: Math.round(Date.now() / 1000) + data.expires_in\n              }, data));\n            case 17:\n              _context44.next = 19;\n              return this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data);\n            case 19:\n              return _context44.abrupt(\"return\", {\n                data: data,\n                error: error\n              });\n            case 22:\n              _context44.prev = 22;\n              _context44.t0 = _context44[\"catch\"](0);\n              if (!isAuthError(_context44.t0)) {\n                _context44.next = 26;\n                break;\n              }\n              return _context44.abrupt(\"return\", {\n                data: null,\n                error: _context44.t0\n              });\n            case 26:\n              throw _context44.t0;\n            case 27:\n            case \"end\":\n              return _context44.stop();\n          }\n        }, _callee44, this, [[0, 22]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#challenge}\n     */\n  }, {\n    key: \"_challenge\",\n    value: function _challenge(params) {\n      var _a;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee45() {\n        var _yield$this$getSessio11, sessionData, sessionError;\n        return _regeneratorRuntime().wrap(function _callee45$(_context45) {\n          while (1) switch (_context45.prev = _context45.next) {\n            case 0:\n              _context45.prev = 0;\n              _context45.next = 3;\n              return this.getSession();\n            case 3:\n              _yield$this$getSessio11 = _context45.sent;\n              sessionData = _yield$this$getSessio11.data;\n              sessionError = _yield$this$getSessio11.error;\n              if (!sessionError) {\n                _context45.next = 8;\n                break;\n              }\n              return _context45.abrupt(\"return\", {\n                data: null,\n                error: sessionError\n              });\n            case 8:\n              _context45.next = 10;\n              return _request(this.fetch, 'POST', \"\".concat(this.url, \"/factors/\").concat(params.factorId, \"/challenge\"), {\n                headers: this.headers,\n                jwt: (_a = sessionData === null || sessionData === void 0 ? void 0 : sessionData.session) === null || _a === void 0 ? void 0 : _a.access_token\n              });\n            case 10:\n              return _context45.abrupt(\"return\", _context45.sent);\n            case 13:\n              _context45.prev = 13;\n              _context45.t0 = _context45[\"catch\"](0);\n              if (!isAuthError(_context45.t0)) {\n                _context45.next = 17;\n                break;\n              }\n              return _context45.abrupt(\"return\", {\n                data: null,\n                error: _context45.t0\n              });\n            case 17:\n              throw _context45.t0;\n            case 18:\n            case \"end\":\n              return _context45.stop();\n          }\n        }, _callee45, this, [[0, 13]]);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#challengeAndVerify}\n     */\n  }, {\n    key: \"_challengeAndVerify\",\n    value: function _challengeAndVerify(params) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee46() {\n        var _yield$this$_challeng, challengeData, challengeError;\n        return _regeneratorRuntime().wrap(function _callee46$(_context46) {\n          while (1) switch (_context46.prev = _context46.next) {\n            case 0:\n              _context46.next = 2;\n              return this._challenge({\n                factorId: params.factorId\n              });\n            case 2:\n              _yield$this$_challeng = _context46.sent;\n              challengeData = _yield$this$_challeng.data;\n              challengeError = _yield$this$_challeng.error;\n              if (!challengeError) {\n                _context46.next = 7;\n                break;\n              }\n              return _context46.abrupt(\"return\", {\n                data: null,\n                error: challengeError\n              });\n            case 7:\n              _context46.next = 9;\n              return this._verify({\n                factorId: params.factorId,\n                challengeId: challengeData.id,\n                code: params.code\n              });\n            case 9:\n              return _context46.abrupt(\"return\", _context46.sent);\n            case 10:\n            case \"end\":\n              return _context46.stop();\n          }\n        }, _callee46, this);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#listFactors}\n     */\n  }, {\n    key: \"_listFactors\",\n    value: function _listFactors() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee47() {\n        var _yield$this$getUser3, user, userError, factors, totp;\n        return _regeneratorRuntime().wrap(function _callee47$(_context47) {\n          while (1) switch (_context47.prev = _context47.next) {\n            case 0:\n              _context47.next = 2;\n              return this.getUser();\n            case 2:\n              _yield$this$getUser3 = _context47.sent;\n              user = _yield$this$getUser3.data.user;\n              userError = _yield$this$getUser3.error;\n              if (!userError) {\n                _context47.next = 7;\n                break;\n              }\n              return _context47.abrupt(\"return\", {\n                data: null,\n                error: userError\n              });\n            case 7:\n              factors = (user === null || user === void 0 ? void 0 : user.factors) || [];\n              totp = factors.filter(function (factor) {\n                return factor.factor_type === 'totp' && factor.status === 'verified';\n              });\n              return _context47.abrupt(\"return\", {\n                data: {\n                  all: factors,\n                  totp: totp\n                },\n                error: null\n              });\n            case 10:\n            case \"end\":\n              return _context47.stop();\n          }\n        }, _callee47, this);\n      }));\n    }\n    /**\n     * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n     */\n  }, {\n    key: \"_getAuthenticatorAssuranceLevel\",\n    value: function _getAuthenticatorAssuranceLevel() {\n      var _a, _b;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee48() {\n        var _yield$this$getSessio12, session, sessionError, payload, currentLevel, nextLevel, verifiedFactors, currentAuthenticationMethods;\n        return _regeneratorRuntime().wrap(function _callee48$(_context48) {\n          while (1) switch (_context48.prev = _context48.next) {\n            case 0:\n              _context48.next = 2;\n              return this.getSession();\n            case 2:\n              _yield$this$getSessio12 = _context48.sent;\n              session = _yield$this$getSessio12.data.session;\n              sessionError = _yield$this$getSessio12.error;\n              if (!sessionError) {\n                _context48.next = 7;\n                break;\n              }\n              return _context48.abrupt(\"return\", {\n                data: null,\n                error: sessionError\n              });\n            case 7:\n              if (session) {\n                _context48.next = 9;\n                break;\n              }\n              return _context48.abrupt(\"return\", {\n                data: {\n                  currentLevel: null,\n                  nextLevel: null,\n                  currentAuthenticationMethods: []\n                },\n                error: null\n              });\n            case 9:\n              payload = this._decodeJWT(session.access_token);\n              currentLevel = null;\n              if (payload.aal) {\n                currentLevel = payload.aal;\n              }\n              nextLevel = currentLevel;\n              verifiedFactors = (_b = (_a = session.user.factors) === null || _a === void 0 ? void 0 : _a.filter(function (factor) {\n                return factor.status === 'verified';\n              })) !== null && _b !== void 0 ? _b : [];\n              if (verifiedFactors.length > 0) {\n                nextLevel = 'aal2';\n              }\n              currentAuthenticationMethods = payload.amr || [];\n              return _context48.abrupt(\"return\", {\n                data: {\n                  currentLevel: currentLevel,\n                  nextLevel: nextLevel,\n                  currentAuthenticationMethods: currentAuthenticationMethods\n                },\n                error: null\n              });\n            case 17:\n            case \"end\":\n              return _context48.stop();\n          }\n        }, _callee48, this);\n      }));\n    }\n  }]);\n  return GoTrueClient;\n}();\nexport { GoTrueClient as default };","map":{"version":3,"names":["GoTrueAdminApi","DEFAULT_HEADERS","EXPIRY_MARGIN","GOTRUE_URL","STORAGE_KEY","AuthImplicitGrantRedirectError","AuthPKCEGrantCodeExchangeError","AuthInvalidCredentialsError","AuthRetryableFetchError","AuthSessionMissingError","AuthInvalidTokenResponseError","AuthUnknownError","isAuthApiError","isAuthError","_request","_sessionResponse","_userResponse","_ssoResponse","decodeJWTPayload","Deferred","getItemAsync","getParameterByName","isBrowser","removeItemAsync","resolveFetch","setItemAsync","uuid","retryable","sleep","generatePKCEVerifier","generatePKCEChallenge","supportsLocalStorage","localStorageAdapter","polyfillGlobalThis","DEFAULT_OPTIONS","url","storageKey","autoRefreshToken","persistSession","detectSessionInUrl","headers","flowType","AUTO_REFRESH_TICK_DURATION","AUTO_REFRESH_TICK_THRESHOLD","GoTrueClient","options","_this","_classCallCheck","stateChangeEmitters","Map","autoRefreshTicker","visibilityChangedCallback","refreshingDeferred","initializePromise","broadcastChannel","settings","Object","assign","inMemorySession","storage","admin","fetch","mfa","verify","_verify","bind","enroll","_enroll","unenroll","_unenroll","challenge","_challenge","listFactors","_listFactors","challengeAndVerify","_challengeAndVerify","getAuthenticatorAssuranceLevel","_getAuthenticatorAssuranceLevel","console","warn","globalThis","BroadcastChannel","e","error","_a","addEventListener","event","__awaiter","_regeneratorRuntime","mark","_callee","wrap","_callee$","_context","prev","next","_notifyAllSubscribers","data","session","stop","initialize","_createClass","key","value","_initialize","_context3","abrupt","_isPKCEFlow","t0","sent","isPKCEFlow","_isImplicitGrantFlow","_getSessionFromUrl","_yield$this$_getSessi","_removeSession","redirectType","_saveSession","setTimeout","_this2","_callee2","_callee2$","_context2","_recoverAndRefresh","t1","_handleVisibilityChange","finish","_callee3","signUp","credentials","_context4","email","password","codeChallenge","codeChallengeMethod","codeVerifier","concat","redirectTo","emailRedirectTo","body","gotrue_meta_security","captcha_token","captchaToken","code_challenge","code_challenge_method","xform","res","phone","_b","channel","_c","_res","user","_callee4","signInWithPassword","_context5","_res2","_callee5","signInWithOAuth","_context6","_handleProviderSignIn","provider","scopes","queryParams","skipBrowserRedirect","_d","_callee6","exchangeCodeForSession","authCode","_context7","auth_code","code_verifier","_yield$_request","_callee7","signInWithIdToken","_context8","token","nonce","id_token","_callee8","signInWithOtp","_context9","create_user","shouldCreateUser","_yield$_request2","_e","_yield$_request3","messageId","message_id","_callee9","verifyOtp","params","type","_context10","_yield$_request4","Error","access_token","_callee10","signInWithSSO","_context11","provider_id","providerId","domain","redirect_to","undefined","skip_http_redirect","_callee11","reauthenticate","getSession","_yield$this$getSessio","_context12","sessionError","jwt","_yield$_request5","_callee12","resend","endpoint","_context13","_yield$_request6","_yield$_request7","_callee13","currentSession","_context14","maybeSession","_isValidSession","hasExpired","expires_at","Date","now","_callRefreshToken","refresh_token","_yield$this$_callRefr","_callee14","getUser","_context15","_yield$this$getSessio2","_callee15","updateUser","attributes","arguments","length","_yield$this$getSessio3","_context16","sessionData","_yield$_request8","userError","_callee16","_decodeJWT","setSession","_context17","timeNow","expiresAt","payload","exp","_yield$this$_callRefr2","refreshedSession","_yield$this$getUser","token_type","expires_in","_callee17","refreshSession","_context18","_yield$this$getSessio4","_yield$this$_callRefr3","_callee18","_context19","_yield$this$exchangeC","URL","window","location","href","searchParams","delete","history","replaceState","state","toString","error_description","error_code","code","provider_token","provider_refresh_token","Math","round","parseInt","_yield$this$getUser2","hash","_callee19","Boolean","currentStorageContent","_context20","_callee20","signOut","_yield$this$getSessio5","_context21","accessToken","_yield$this$admin$sig","status","_callee21","onAuthStateChange","callback","_this3","id","subscription","unsubscribe","set","emitInitialSession","_yield$this$getSessio6","_context22","get","_callee22","resetPasswordForEmail","_context23","_callee23","_refreshAccessToken","refreshToken","startedAt","_context25","attempt","_this4","_callee24","_callee24$","_context24","_","result","_callee25","isValidSession","_getUrlForProvider","_context26","_callee26","_context27","Infinity","_yield$this$_callRefr4","log","message","_callee27","_context28","promise","_yield$this$_refreshA","resolve","reject","_callee28","broadcast","postMessage","errors","promises","Array","from","values","map","x","_this5","_callee29","_callee29$","_context29","push","_context30","Promise","all","i","_callee30","_context31","_persistSession","_callee31","_context32","_callee32","_removeVisibilityChangedCallback","removeEventListener","_startAutoRefresh","_stopAutoRefresh","ticker","setInterval","_this6","_autoRefreshTokenTick","unref","Deno","unrefTimer","_context33","_callee33","clearInterval","_context34","_callee34","startAutoRefresh","_context35","_callee35","stopAutoRefresh","_context36","_callee36","_context37","_yield$this$getSessio7","expiresInTicks","floor","_callee37","_context39","_this7","_callee38","_callee38$","_context38","_onVisibilityChanged","_callee39","isInitial","document","visibilityState","_context40","_callee40","urlParams","encodeURIComponent","_context41","flowParams","URLSearchParams","query","join","_callee41","_yield$this$getSessio8","_context42","factorId","_callee42","_yield$this$getSessio9","_context43","friendly_name","friendlyName","factor_type","factorType","issuer","_yield$_request9","totp","qr_code","_callee43","_yield$this$getSessio10","_context44","challenge_id","challengeId","_yield$_request10","_callee44","_yield$this$getSessio11","_context45","_callee45","_yield$this$_challeng","_context46","challengeData","challengeError","_callee46","_yield$this$getUser3","_context47","factors","filter","factor","_callee47","_yield$this$getSessio12","_context48","currentLevel","nextLevel","currentAuthenticationMethods","aal","verifiedFactors","amr","_callee48","default"],"sources":["/Users/huangjiatan/Desktop/today_i_learned/node_modules/@supabase/gotrue-js/src/GoTrueClient.ts"],"sourcesContent":["import GoTrueAdminApi from './GoTrueAdminApi'\nimport { DEFAULT_HEADERS, EXPIRY_MARGIN, GOTRUE_URL, STORAGE_KEY } from './lib/constants'\nimport {\n  AuthError,\n  AuthImplicitGrantRedirectError,\n  AuthPKCEGrantCodeExchangeError,\n  AuthInvalidCredentialsError,\n  AuthRetryableFetchError,\n  AuthSessionMissingError,\n  AuthInvalidTokenResponseError,\n  AuthUnknownError,\n  isAuthApiError,\n  isAuthError,\n} from './lib/errors'\nimport { Fetch, _request, _sessionResponse, _userResponse, _ssoResponse } from './lib/fetch'\nimport {\n  decodeJWTPayload,\n  Deferred,\n  getItemAsync,\n  getParameterByName,\n  isBrowser,\n  removeItemAsync,\n  resolveFetch,\n  setItemAsync,\n  uuid,\n  retryable,\n  sleep,\n  generatePKCEVerifier,\n  generatePKCEChallenge,\n  supportsLocalStorage,\n} from './lib/helpers'\nimport localStorageAdapter from './lib/local-storage'\nimport { polyfillGlobalThis } from './lib/polyfills'\n\nimport type {\n  AuthChangeEvent,\n  AuthResponse,\n  AuthTokenResponse,\n  AuthOtpResponse,\n  CallRefreshTokenResult,\n  GoTrueClientOptions,\n  InitializeResult,\n  OAuthResponse,\n  SSOResponse,\n  Provider,\n  Session,\n  SignInWithIdTokenCredentials,\n  SignInWithOAuthCredentials,\n  SignInWithPasswordCredentials,\n  SignInWithPasswordlessCredentials,\n  SignUpWithPasswordCredentials,\n  SignInWithSSO,\n  Subscription,\n  SupportedStorage,\n  User,\n  UserAttributes,\n  UserResponse,\n  VerifyOtpParams,\n  GoTrueMFAApi,\n  MFAEnrollParams,\n  AuthMFAEnrollResponse,\n  MFAChallengeParams,\n  AuthMFAChallengeResponse,\n  MFAUnenrollParams,\n  AuthMFAUnenrollResponse,\n  MFAVerifyParams,\n  AuthMFAVerifyResponse,\n  AuthMFAListFactorsResponse,\n  AMREntry,\n  AuthMFAGetAuthenticatorAssuranceLevelResponse,\n  AuthenticatorAssuranceLevels,\n  Factor,\n  MFAChallengeAndVerifyParams,\n  ResendParams,\n  AuthFlowType,\n} from './lib/types'\n\npolyfillGlobalThis() // Make \"globalThis\" available\n\nconst DEFAULT_OPTIONS: Omit<Required<GoTrueClientOptions>, 'fetch' | 'storage'> = {\n  url: GOTRUE_URL,\n  storageKey: STORAGE_KEY,\n  autoRefreshToken: true,\n  persistSession: true,\n  detectSessionInUrl: true,\n  headers: DEFAULT_HEADERS,\n  flowType: 'implicit',\n}\n\n/** Current session will be checked for refresh at this interval. */\nconst AUTO_REFRESH_TICK_DURATION = 30 * 1000\n\n/**\n * A token refresh will be attempted this many ticks before the current session expires. */\nconst AUTO_REFRESH_TICK_THRESHOLD = 3\n\nexport default class GoTrueClient {\n  /**\n   * Namespace for the GoTrue admin methods.\n   * These methods should only be used in a trusted server-side environment.\n   */\n  admin: GoTrueAdminApi\n  /**\n   * Namespace for the MFA methods.\n   */\n  mfa: GoTrueMFAApi\n  /**\n   * The storage key used to identify the values saved in localStorage\n   */\n  protected storageKey: string\n\n  /**\n   * The session object for the currently logged in user. If null, it means there isn't a logged-in user.\n   * Only used if persistSession is false.\n   */\n  protected inMemorySession: Session | null\n\n  protected flowType: AuthFlowType\n\n  protected autoRefreshToken: boolean\n  protected persistSession: boolean\n  protected storage: SupportedStorage\n  protected stateChangeEmitters: Map<string, Subscription> = new Map()\n  protected autoRefreshTicker: ReturnType<typeof setInterval> | null = null\n  protected visibilityChangedCallback: (() => Promise<any>) | null = null\n  protected refreshingDeferred: Deferred<CallRefreshTokenResult> | null = null\n  /**\n   * Keeps track of the async client initialization.\n   * When null or not yet resolved the auth state is `unknown`\n   * Once resolved the the auth state is known and it's save to call any further client methods.\n   * Keep extra care to never reject or throw uncaught errors\n   */\n  protected initializePromise: Promise<InitializeResult> | null = null\n  protected detectSessionInUrl = true\n  protected url: string\n  protected headers: {\n    [key: string]: string\n  }\n  protected fetch: Fetch\n\n  /**\n   * Used to broadcast state change events to other tabs listening.\n   */\n  protected broadcastChannel: BroadcastChannel | null = null\n\n  /**\n   * Create a new client for use in the browser.\n   */\n  constructor(options: GoTrueClientOptions) {\n    const settings = { ...DEFAULT_OPTIONS, ...options }\n    this.inMemorySession = null\n    this.storageKey = settings.storageKey\n    this.autoRefreshToken = settings.autoRefreshToken\n    this.persistSession = settings.persistSession\n    this.storage = settings.storage || localStorageAdapter\n    this.admin = new GoTrueAdminApi({\n      url: settings.url,\n      headers: settings.headers,\n      fetch: settings.fetch,\n    })\n\n    this.url = settings.url\n    this.headers = settings.headers\n    this.fetch = resolveFetch(settings.fetch)\n    this.detectSessionInUrl = settings.detectSessionInUrl\n    this.flowType = settings.flowType\n\n    this.mfa = {\n      verify: this._verify.bind(this),\n      enroll: this._enroll.bind(this),\n      unenroll: this._unenroll.bind(this),\n      challenge: this._challenge.bind(this),\n      listFactors: this._listFactors.bind(this),\n      challengeAndVerify: this._challengeAndVerify.bind(this),\n      getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),\n    }\n\n    if (this.persistSession && this.storage === localStorageAdapter && !supportsLocalStorage()) {\n      console.warn(\n        `No storage option exists to persist the session, which may result in unexpected behavior when using auth.\n        If you want to set persistSession to true, please provide a storage option or you may set persistSession to false to disable this warning.`\n      )\n    }\n\n    if (isBrowser() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {\n      try {\n        this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)\n      } catch (e: any) {\n        console.error(\n          'Failed to create a new BroadcastChannel, multi-tab state changes will not be available',\n          e\n        )\n      }\n\n      this.broadcastChannel?.addEventListener('message', async (event) => {\n        await this._notifyAllSubscribers(event.data.event, event.data.session, false) // broadcast = false so we don't get an endless loop of messages\n      })\n    }\n\n    this.initialize()\n  }\n\n  /**\n   * Initializes the client session either from the url or from storage.\n   * This method is automatically called when instantiating the client, but should also be called\n   * manually when checking for an error from an auth redirect (oauth, magiclink, password recovery, etc).\n   */\n  initialize(): Promise<InitializeResult> {\n    if (!this.initializePromise) {\n      this.initializePromise = this._initialize()\n    }\n\n    return this.initializePromise\n  }\n\n  /**\n   * IMPORTANT:\n   * 1. Never throw in this method, as it is called from the constructor\n   * 2. Never return a session from this method as it would be cached over\n   *    the whole lifetime of the client\n   */\n  private async _initialize(): Promise<InitializeResult> {\n    if (this.initializePromise) {\n      return this.initializePromise\n    }\n\n    try {\n      const isPKCEFlow = isBrowser() ? await this._isPKCEFlow() : false\n      if (isPKCEFlow || (this.detectSessionInUrl && this._isImplicitGrantFlow())) {\n        const { data, error } = await this._getSessionFromUrl(isPKCEFlow)\n        if (error) {\n          // failed login attempt via url,\n          // remove old session as in verifyOtp, signUp and signInWith*\n          await this._removeSession()\n\n          return { error }\n        }\n\n        const { session, redirectType } = data\n\n        await this._saveSession(session)\n\n        setTimeout(async () => {\n          if (redirectType === 'recovery') {\n            await this._notifyAllSubscribers('PASSWORD_RECOVERY', session)\n          } else {\n            await this._notifyAllSubscribers('SIGNED_IN', session)\n          }\n        }, 0)\n\n        return { error: null }\n      }\n\n      // no login attempt via callback url try to recover session from storage\n      await this._recoverAndRefresh()\n      return { error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { error }\n      }\n\n      return {\n        error: new AuthUnknownError('Unexpected error during initialization', error),\n      }\n    } finally {\n      await this._handleVisibilityChange()\n    }\n  }\n\n  /**\n   * Creates a new user.\n   *\n   * Be aware that if a user account exists in the system you may get back an\n   * error message that attempts to hide this information from the user.\n   * This method has support for PKCE via email signups. The PKCE flow cannot be used when autoconfirm is enabled.\n   *\n   * @returns A logged-in session if the server has \"autoconfirm\" ON\n   * @returns A user if the server has \"autoconfirm\" OFF\n   */\n  async signUp(credentials: SignUpWithPasswordCredentials): Promise<AuthResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce') {\n          const codeVerifier = generatePKCEVerifier()\n          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n          codeChallenge = await generatePKCEChallenge(codeVerifier)\n          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n        }\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          redirectTo: options?.emailRedirectTo,\n          body: {\n            email,\n            password,\n            data: options?.data ?? {},\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/signup`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            data: options?.data ?? {},\n            channel: options?.channel ?? 'sms',\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n\n      const { data, error } = res\n\n      if (error || !data) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      const session: Session | null = data.session\n      const user: User | null = data.user\n\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user with an email and password or phone and password.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or that the\n   * email/phone and password combination is wrong or that the account can only\n   * be accessed via social login.\n   */\n  async signInWithPassword(credentials: SignInWithPasswordCredentials): Promise<AuthTokenResponse> {\n    try {\n      await this._removeSession()\n\n      let res: AuthResponse\n      if ('email' in credentials) {\n        const { email, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            email,\n            password,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else if ('phone' in credentials) {\n        const { phone, password, options } = credentials\n        res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=password`, {\n          headers: this.headers,\n          body: {\n            phone,\n            password,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n          xform: _sessionResponse,\n        })\n      } else {\n        throw new AuthInvalidCredentialsError(\n          'You must provide either an email or phone number and a password'\n        )\n      }\n      const { data, error } = res\n\n      if (error) {\n        return { data: { user: null, session: null }, error }\n      } else if (!data || !data.session || !data.user) {\n        return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() }\n      }\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data: { user: data.user, session: data.session }, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in an existing user via a third-party provider.\n   * This method supports the PKCE flow.\n   */\n  async signInWithOAuth(credentials: SignInWithOAuthCredentials): Promise<OAuthResponse> {\n    await this._removeSession()\n\n    return await this._handleProviderSignIn(credentials.provider, {\n      redirectTo: credentials.options?.redirectTo,\n      scopes: credentials.options?.scopes,\n      queryParams: credentials.options?.queryParams,\n      skipBrowserRedirect: credentials.options?.skipBrowserRedirect,\n    })\n  }\n\n  /**\n   * Log in an existing user by exchanging an Auth Code issued during the PKCE flow.\n   */\n  async exchangeCodeForSession(authCode: string): Promise<AuthTokenResponse> {\n    const codeVerifier = await getItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    const { data, error } = await _request(\n      this.fetch,\n      'POST',\n      `${this.url}/token?grant_type=pkce`,\n      {\n        headers: this.headers,\n        body: {\n          auth_code: authCode,\n          code_verifier: codeVerifier,\n        },\n        xform: _sessionResponse,\n      }\n    )\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    if (error) {\n      return { data: { user: null, session: null }, error }\n    } else if (!data || !data.session || !data.user) {\n      return { data: { user: null, session: null }, error: new AuthInvalidTokenResponseError() }\n    }\n    if (data.session) {\n      await this._saveSession(data.session)\n      await this._notifyAllSubscribers('SIGNED_IN', data.session)\n    }\n    return { data, error }\n  }\n\n  /**\n   * Allows signing in with an ID token issued by certain supported providers.\n   * The ID token is verified for validity and a new session is established.\n   *\n   * @experimental\n   */\n  async signInWithIdToken(credentials: SignInWithIdTokenCredentials): Promise<AuthTokenResponse> {\n    await this._removeSession()\n\n    try {\n      const { options, provider, token, nonce } = credentials\n\n      const res = await _request(this.fetch, 'POST', `${this.url}/token?grant_type=id_token`, {\n        headers: this.headers,\n        body: {\n          provider,\n          id_token: token,\n          nonce,\n          gotrue_meta_security: { captcha_token: options?.captchaToken },\n        },\n        xform: _sessionResponse,\n      })\n\n      const { data, error } = res\n      if (error) {\n        return { data: { user: null, session: null }, error }\n      } else if (!data || !data.session || !data.user) {\n        return {\n          data: { user: null, session: null },\n          error: new AuthInvalidTokenResponseError(),\n        }\n      }\n      if (data.session) {\n        await this._saveSession(data.session)\n        await this._notifyAllSubscribers('SIGNED_IN', data.session)\n      }\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user using magiclink or a one-time password (OTP).\n   *\n   * If the `{{ .ConfirmationURL }}` variable is specified in the email template, a magiclink will be sent.\n   * If the `{{ .Token }}` variable is specified in the email template, an OTP will be sent.\n   * If you're using phone sign-ins, only an OTP will be sent. You won't be able to send a magiclink for phone sign-ins.\n   *\n   * Be aware that you may get back an error message that will not distinguish\n   * between the cases where the account does not exist or, that the account\n   * can only be accessed via social login.\n   *\n   * Do note that you will need to configure a Whatsapp sender on Twilio\n   * if you are using phone sign in with the 'whatsapp' channel. The whatsapp\n   * channel is not supported on other providers\n   * at this time.\n   * This method supports PKCE when an email is passed.\n   */\n  async signInWithOtp(credentials: SignInWithPasswordlessCredentials): Promise<AuthOtpResponse> {\n    try {\n      await this._removeSession()\n\n      if ('email' in credentials) {\n        const { email, options } = credentials\n        let codeChallenge: string | null = null\n        let codeChallengeMethod: string | null = null\n        if (this.flowType === 'pkce') {\n          const codeVerifier = generatePKCEVerifier()\n          await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n          codeChallenge = await generatePKCEChallenge(codeVerifier)\n          codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n        }\n        const { error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            email,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            code_challenge: codeChallenge,\n            code_challenge_method: codeChallengeMethod,\n          },\n          redirectTo: options?.emailRedirectTo,\n        })\n        return { data: { user: null, session: null }, error }\n      }\n      if ('phone' in credentials) {\n        const { phone, options } = credentials\n        const { data, error } = await _request(this.fetch, 'POST', `${this.url}/otp`, {\n          headers: this.headers,\n          body: {\n            phone,\n            data: options?.data ?? {},\n            create_user: options?.shouldCreateUser ?? true,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n            channel: options?.channel ?? 'sms',\n          },\n        })\n        return { data: { user: null, session: null, messageId: data?.message_id }, error }\n      }\n      throw new AuthInvalidCredentialsError('You must provide either an email or phone number.')\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Log in a user given a User supplied OTP received via mobile.\n   */\n  async verifyOtp(params: VerifyOtpParams): Promise<AuthResponse> {\n    try {\n      if (params.type !== 'email_change' && params.type !== 'phone_change') {\n        // we don't want to remove the authenticated session if the user is performing an email_change or phone_change verification\n        await this._removeSession()\n      }\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/verify`, {\n        headers: this.headers,\n        body: {\n          ...params,\n          gotrue_meta_security: { captcha_token: params.options?.captchaToken },\n        },\n        redirectTo: params.options?.redirectTo,\n        xform: _sessionResponse,\n      })\n\n      if (error) {\n        throw error\n      }\n\n      if (!data) {\n        throw new Error('An error occurred on token verification.')\n      }\n\n      const session: Session | null = data.session\n      const user: User = data.user\n\n      if (session?.access_token) {\n        await this._saveSession(session as Session)\n        await this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Attempts a single-sign on using an enterprise Identity Provider. A\n   * successful SSO attempt will redirect the current page to the identity\n   * provider authorization page. The redirect URL is implementation and SSO\n   * protocol specific.\n   *\n   * You can use it by providing a SSO domain. Typically you can extract this\n   * domain by asking users for their email address. If this domain is\n   * registered on the Auth instance the redirect will use that organization's\n   * currently active SSO Identity Provider for the login.\n   *\n   * If you have built an organization-specific login page, you can use the\n   * organization's SSO Identity Provider UUID directly instead.\n   */\n  async signInWithSSO(params: SignInWithSSO): Promise<SSOResponse> {\n    try {\n      await this._removeSession()\n\n      return await _request(this.fetch, 'POST', `${this.url}/sso`, {\n        body: {\n          ...('providerId' in params ? { provider_id: params.providerId } : null),\n          ...('domain' in params ? { domain: params.domain } : null),\n          redirect_to: params.options?.redirectTo ?? undefined,\n          ...(params?.options?.captchaToken\n            ? { gotrue_meta_security: { captcha_token: params.options.captchaToken } }\n            : null),\n          skip_http_redirect: true, // fetch does not handle redirects\n        },\n        headers: this.headers,\n        xform: _ssoResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Sends a reauthentication OTP to the user's email or phone number.\n   * Requires the user to be signed-in.\n   */\n  async reauthenticate(): Promise<AuthResponse> {\n    try {\n      const {\n        data: { session },\n        error: sessionError,\n      } = await this.getSession()\n      if (sessionError) throw sessionError\n      if (!session) throw new AuthSessionMissingError()\n\n      const { error } = await _request(this.fetch, 'GET', `${this.url}/reauthenticate`, {\n        headers: this.headers,\n        jwt: session.access_token,\n      })\n      return { data: { user: null, session: null }, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Resends an existing signup confirmation email, email change email, SMS OTP or phone change OTP.\n   */\n  async resend(credentials: ResendParams): Promise<AuthOtpResponse> {\n    try {\n      await this._removeSession()\n      const endpoint = `${this.url}/resend`\n      if ('email' in credentials) {\n        const { email, type, options } = credentials\n        const { error } = await _request(this.fetch, 'POST', endpoint, {\n          headers: this.headers,\n          body: {\n            email,\n            type,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n        })\n        return { data: { user: null, session: null }, error }\n      } else if ('phone' in credentials) {\n        const { phone, type, options } = credentials\n        const { data, error } = await _request(this.fetch, 'POST', endpoint, {\n          headers: this.headers,\n          body: {\n            phone,\n            type,\n            gotrue_meta_security: { captcha_token: options?.captchaToken },\n          },\n        })\n        return { data: { user: null, session: null, messageId: data?.message_id }, error }\n      }\n      throw new AuthInvalidCredentialsError(\n        'You must provide either an email or phone number and a type'\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * Returns the session, refreshing it if necessary.\n   * The session returned can be null if the session is not detected which can happen in the event a user is not signed-in or has logged out.\n   */\n  async getSession(): Promise<\n    | {\n        data: {\n          session: Session\n        }\n        error: null\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: AuthError\n      }\n    | {\n        data: {\n          session: null\n        }\n        error: null\n      }\n  > {\n    // make sure we've read the session from the url if there is one\n    // save to just await, as long we make sure _initialize() never throws\n    await this.initializePromise\n\n    let currentSession: Session | null = null\n\n    if (this.persistSession) {\n      const maybeSession = await getItemAsync(this.storage, this.storageKey)\n\n      if (maybeSession !== null) {\n        if (this._isValidSession(maybeSession)) {\n          currentSession = maybeSession\n        } else {\n          await this._removeSession()\n        }\n      }\n    } else {\n      currentSession = this.inMemorySession\n    }\n\n    if (!currentSession) {\n      return { data: { session: null }, error: null }\n    }\n\n    const hasExpired = currentSession.expires_at\n      ? currentSession.expires_at <= Date.now() / 1000\n      : false\n    if (!hasExpired) {\n      return { data: { session: currentSession }, error: null }\n    }\n\n    const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n    if (error) {\n      return { data: { session: null }, error }\n    }\n\n    return { data: { session }, error: null }\n  }\n\n  /**\n   * Gets the current user details if there is an existing session.\n   * @param jwt Takes in an optional access token jwt. If no jwt is provided, getUser() will attempt to get the jwt from the current session.\n   */\n  async getUser(jwt?: string): Promise<UserResponse> {\n    try {\n      if (!jwt) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        // Default to Authorization header if there is no existing session\n        jwt = data.session?.access_token ?? undefined\n      }\n\n      return await _request(this.fetch, 'GET', `${this.url}/user`, {\n        headers: this.headers,\n        jwt: jwt,\n        xform: _userResponse,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Updates user data for a logged in user.\n   */\n  async updateUser(\n    attributes: UserAttributes,\n    options: {\n      emailRedirectTo?: string | undefined\n    } = {}\n  ): Promise<UserResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        throw sessionError\n      }\n      if (!sessionData.session) {\n        throw new AuthSessionMissingError()\n      }\n      const session: Session = sessionData.session\n      const { data, error: userError } = await _request(this.fetch, 'PUT', `${this.url}/user`, {\n        headers: this.headers,\n        redirectTo: options?.emailRedirectTo,\n        body: attributes,\n        jwt: session.access_token,\n        xform: _userResponse,\n      })\n      if (userError) throw userError\n      session.user = data.user as User\n      await this._saveSession(session)\n      await this._notifyAllSubscribers('USER_UPDATED', session)\n\n      return { data: { user: session.user }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Decodes a JWT (without performing any validation).\n   */\n  private _decodeJWT(jwt: string): {\n    exp?: number\n    aal?: AuthenticatorAssuranceLevels | null\n    amr?: AMREntry[] | null\n  } {\n    return decodeJWTPayload(jwt)\n  }\n\n  /**\n   * Sets the session data from the current session. If the current session is expired, setSession will take care of refreshing it to obtain a new session.\n   * If the refresh token or access token in the current session is invalid, an error will be thrown.\n   * @param currentSession The current session that minimally contains an access token and refresh token.\n   */\n  async setSession(currentSession: {\n    access_token: string\n    refresh_token: string\n  }): Promise<AuthResponse> {\n    try {\n      if (!currentSession.access_token || !currentSession.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const timeNow = Date.now() / 1000\n      let expiresAt = timeNow\n      let hasExpired = true\n      let session: Session | null = null\n      const payload = decodeJWTPayload(currentSession.access_token)\n      if (payload.exp) {\n        expiresAt = payload.exp\n        hasExpired = expiresAt <= timeNow\n      }\n\n      if (hasExpired) {\n        const { session: refreshedSession, error } = await this._callRefreshToken(\n          currentSession.refresh_token\n        )\n        if (error) {\n          return { data: { user: null, session: null }, error: error }\n        }\n\n        if (!refreshedSession) {\n          return { data: { user: null, session: null }, error: null }\n        }\n        session = refreshedSession\n      } else {\n        const { data, error } = await this.getUser(currentSession.access_token)\n        if (error) {\n          throw error\n        }\n        session = {\n          access_token: currentSession.access_token,\n          refresh_token: currentSession.refresh_token,\n          user: data.user,\n          token_type: 'bearer',\n          expires_in: expiresAt - timeNow,\n          expires_at: expiresAt,\n        }\n        await this._saveSession(session)\n        await this._notifyAllSubscribers('SIGNED_IN', session)\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Returns a new session, regardless of expiry status.\n   * Takes in an optional current session. If not passed in, then refreshSession() will attempt to retrieve it from getSession().\n   * If the current session's refresh token is invalid, an error will be thrown.\n   * @param currentSession The current session. If passed in, it must contain a refresh token.\n   */\n  async refreshSession(currentSession?: { refresh_token: string }): Promise<AuthResponse> {\n    try {\n      if (!currentSession) {\n        const { data, error } = await this.getSession()\n        if (error) {\n          throw error\n        }\n\n        currentSession = data.session ?? undefined\n      }\n\n      if (!currentSession?.refresh_token) {\n        throw new AuthSessionMissingError()\n      }\n\n      const { session, error } = await this._callRefreshToken(currentSession.refresh_token)\n      if (error) {\n        return { data: { user: null, session: null }, error: error }\n      }\n\n      if (!session) {\n        return { data: { user: null, session: null }, error: null }\n      }\n\n      return { data: { user: session.user, session }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { user: null, session: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Gets the session data from a URL string\n   */\n  private async _getSessionFromUrl(isPKCEFlow: boolean): Promise<\n    | {\n        data: { session: Session; redirectType: string | null }\n        error: null\n      }\n    | { data: { session: null; redirectType: null }; error: AuthError }\n  > {\n    try {\n      if (!isBrowser()) throw new AuthImplicitGrantRedirectError('No browser detected.')\n      if (this.flowType === 'implicit' && !this._isImplicitGrantFlow()) {\n        throw new AuthImplicitGrantRedirectError('Not a valid implicit grant flow url.')\n      } else if (this.flowType == 'pkce' && !isPKCEFlow) {\n        throw new AuthPKCEGrantCodeExchangeError('Not a valid PKCE flow url.')\n      }\n      if (isPKCEFlow) {\n        const authCode = getParameterByName('code')\n        if (!authCode) throw new AuthPKCEGrantCodeExchangeError('No code detected.')\n        const { data, error } = await this.exchangeCodeForSession(authCode)\n        if (error) throw error\n        if (!data.session) throw new AuthPKCEGrantCodeExchangeError('No session detected.')\n        let url = new URL(window.location.href)\n        url.searchParams.delete('code')\n        window.history.replaceState(window.history.state, '', url.toString())\n        return { data: { session: data.session, redirectType: null }, error: null }\n      }\n\n      const error_description = getParameterByName('error_description')\n      if (error_description) {\n        const error_code = getParameterByName('error_code')\n        if (!error_code) throw new AuthImplicitGrantRedirectError('No error_code detected.')\n        const error = getParameterByName('error')\n        if (!error) throw new AuthImplicitGrantRedirectError('No error detected.')\n\n        throw new AuthImplicitGrantRedirectError(error_description, { error, code: error_code })\n      }\n\n      const provider_token = getParameterByName('provider_token')\n      const provider_refresh_token = getParameterByName('provider_refresh_token')\n      const access_token = getParameterByName('access_token')\n      if (!access_token) throw new AuthImplicitGrantRedirectError('No access_token detected.')\n      const expires_in = getParameterByName('expires_in')\n      if (!expires_in) throw new AuthImplicitGrantRedirectError('No expires_in detected.')\n      const refresh_token = getParameterByName('refresh_token')\n      if (!refresh_token) throw new AuthImplicitGrantRedirectError('No refresh_token detected.')\n      const token_type = getParameterByName('token_type')\n      if (!token_type) throw new AuthImplicitGrantRedirectError('No token_type detected.')\n\n      const timeNow = Math.round(Date.now() / 1000)\n      const expires_at = timeNow + parseInt(expires_in)\n\n      const { data, error } = await this.getUser(access_token)\n      if (error) throw error\n      const user: User = data.user\n      const session: Session = {\n        provider_token,\n        provider_refresh_token,\n        access_token,\n        expires_in: parseInt(expires_in),\n        expires_at,\n        refresh_token,\n        token_type,\n        user,\n      }\n      const redirectType = getParameterByName('type')\n\n      // Remove tokens from URL\n      window.location.hash = ''\n\n      return { data: { session, redirectType }, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, redirectType: null }, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Checks if the current URL contains parameters given by an implicit oauth grant flow (https://www.rfc-editor.org/rfc/rfc6749.html#section-4.2)\n   */\n  private _isImplicitGrantFlow(): boolean {\n    return (\n      isBrowser() &&\n      (Boolean(getParameterByName('access_token')) ||\n        Boolean(getParameterByName('error_description')))\n    )\n  }\n  /**\n   * Checks if the current URL and backing storage contain parameters given by a PKCE flow\n   */\n  private async _isPKCEFlow(): Promise<boolean> {\n    const currentStorageContent = await getItemAsync(\n      this.storage,\n      `${this.storageKey}-code-verifier`\n    )\n    return Boolean(getParameterByName('code')) && Boolean(currentStorageContent)\n  }\n\n  /**\n   * Inside a browser context, `signOut()` will remove the logged in user from the browser session\n   * and log them out - removing all items from localstorage and then trigger a `\"SIGNED_OUT\"` event.\n   *\n   * For server-side management, you can revoke all refresh tokens for a user by passing a user's JWT through to `auth.api.signOut(JWT: string)`.\n   * There is no way to revoke a user's access token jwt until it expires. It is recommended to set a shorter expiry on the jwt for this reason.\n   */\n  async signOut(): Promise<{ error: AuthError | null }> {\n    const { data, error: sessionError } = await this.getSession()\n    if (sessionError) {\n      return { error: sessionError }\n    }\n    const accessToken = data.session?.access_token\n    if (accessToken) {\n      const { error } = await this.admin.signOut(accessToken)\n      if (error) {\n        // ignore 404s since user might not exist anymore\n        // ignore 401s since an invalid or expired JWT should sign out the current session\n        if (!(isAuthApiError(error) && (error.status === 404 || error.status === 401))) {\n          return { error }\n        }\n      }\n    }\n    await this._removeSession()\n    await removeItemAsync(this.storage, `${this.storageKey}-code-verifier`)\n    await this._notifyAllSubscribers('SIGNED_OUT', null)\n    return { error: null }\n  }\n\n  /**\n   * Receive a notification every time an auth event happens.\n   * @param callback A callback function to be invoked when an auth event happens.\n   */\n  onAuthStateChange(\n    callback: (event: AuthChangeEvent, session: Session | null) => void | Promise<void>\n  ): {\n    data: { subscription: Subscription }\n  } {\n    const id: string = uuid()\n    const subscription: Subscription = {\n      id,\n      callback,\n      unsubscribe: () => {\n        this.stateChangeEmitters.delete(id)\n      },\n    }\n\n    this.stateChangeEmitters.set(id, subscription)\n\n    this.emitInitialSession(id)\n\n    return { data: { subscription } }\n  }\n\n  private async emitInitialSession(id: string): Promise<void> {\n    try {\n      const {\n        data: { session },\n        error,\n      } = await this.getSession()\n      if (error) throw error\n\n      await this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', session)\n    } catch (err) {\n      await this.stateChangeEmitters.get(id)?.callback('INITIAL_SESSION', null)\n      console.error(err)\n    }\n  }\n\n  /**\n   * Sends a password reset request to an email address.\n   * This method supports the PKCE flow.\n   * @param email The email address of the user.\n   * @param options.redirectTo The URL to send the user to after they click the password reset link.\n   * @param options.captchaToken Verification token received when the user completes the captcha on the site.\n   */\n  async resetPasswordForEmail(\n    email: string,\n    options: {\n      redirectTo?: string\n      captchaToken?: string\n    } = {}\n  ): Promise<\n    | {\n        data: {}\n        error: null\n      }\n    | { data: null; error: AuthError }\n  > {\n    let codeChallenge: string | null = null\n    let codeChallengeMethod: string | null = null\n    if (this.flowType === 'pkce') {\n      const codeVerifier = generatePKCEVerifier()\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n      codeChallenge = await generatePKCEChallenge(codeVerifier)\n      codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n    }\n    try {\n      return await _request(this.fetch, 'POST', `${this.url}/recover`, {\n        body: {\n          email,\n          code_challenge: codeChallenge,\n          code_challenge_method: codeChallengeMethod,\n          gotrue_meta_security: { captcha_token: options.captchaToken },\n        },\n        headers: this.headers,\n        redirectTo: options.redirectTo,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n\n      throw error\n    }\n  }\n\n  /**\n   * Generates a new JWT.\n   * @param refreshToken A valid refresh token that was returned on login.\n   */\n  private async _refreshAccessToken(refreshToken: string): Promise<AuthResponse> {\n    try {\n      const startedAt = Date.now()\n\n      // will attempt to refresh the token with exponential backoff\n      return await retryable(\n        async (attempt) => {\n          await sleep(attempt * 200) // 0, 200, 400, 800, ...\n\n          return await _request(this.fetch, 'POST', `${this.url}/token?grant_type=refresh_token`, {\n            body: { refresh_token: refreshToken },\n            headers: this.headers,\n            xform: _sessionResponse,\n          })\n        },\n        (attempt, _, result) =>\n          result &&\n          result.error &&\n          result.error instanceof AuthRetryableFetchError &&\n          // retryable only if the request can be sent before the backoff overflows the tick duration\n          Date.now() + (attempt + 1) * 200 - startedAt < AUTO_REFRESH_TICK_DURATION\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: { session: null, user: null }, error }\n      }\n      throw error\n    }\n  }\n\n  private _isValidSession(maybeSession: unknown): maybeSession is Session {\n    const isValidSession =\n      typeof maybeSession === 'object' &&\n      maybeSession !== null &&\n      'access_token' in maybeSession &&\n      'refresh_token' in maybeSession &&\n      'expires_at' in maybeSession\n\n    return isValidSession\n  }\n\n  private async _handleProviderSignIn(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n      skipBrowserRedirect?: boolean\n    }\n  ) {\n    const url: string = await this._getUrlForProvider(provider, {\n      redirectTo: options.redirectTo,\n      scopes: options.scopes,\n      queryParams: options.queryParams,\n    })\n    // try to open on the browser\n    if (isBrowser() && !options.skipBrowserRedirect) {\n      window.location.assign(url)\n    }\n\n    return { data: { provider, url }, error: null }\n  }\n\n  /**\n   * Recovers the session from LocalStorage and refreshes\n   * Note: this method is async to accommodate for AsyncStorage e.g. in React native.\n   */\n  private async _recoverAndRefresh() {\n    try {\n      const currentSession = await getItemAsync(this.storage, this.storageKey)\n      if (!this._isValidSession(currentSession)) {\n        if (currentSession !== null) {\n          await this._removeSession()\n        }\n\n        return\n      }\n\n      const timeNow = Math.round(Date.now() / 1000)\n\n      if ((currentSession.expires_at ?? Infinity) < timeNow + EXPIRY_MARGIN) {\n        if (this.autoRefreshToken && currentSession.refresh_token) {\n          const { error } = await this._callRefreshToken(currentSession.refresh_token)\n\n          if (error) {\n            console.log(error.message)\n            await this._removeSession()\n          }\n        }\n      } else {\n        if (this.persistSession) {\n          await this._saveSession(currentSession)\n        }\n        await this._notifyAllSubscribers('SIGNED_IN', currentSession)\n      }\n    } catch (err) {\n      console.error(err)\n      return\n    }\n  }\n\n  private async _callRefreshToken(refreshToken: string): Promise<CallRefreshTokenResult> {\n    // refreshing is already in progress\n    if (this.refreshingDeferred) {\n      return this.refreshingDeferred.promise\n    }\n\n    try {\n      this.refreshingDeferred = new Deferred<CallRefreshTokenResult>()\n\n      if (!refreshToken) {\n        throw new AuthSessionMissingError()\n      }\n      const { data, error } = await this._refreshAccessToken(refreshToken)\n      if (error) throw error\n      if (!data.session) throw new AuthSessionMissingError()\n\n      await this._saveSession(data.session)\n      await this._notifyAllSubscribers('TOKEN_REFRESHED', data.session)\n\n      const result = { session: data.session, error: null }\n\n      this.refreshingDeferred.resolve(result)\n\n      return result\n    } catch (error) {\n      if (isAuthError(error)) {\n        const result = { session: null, error }\n\n        this.refreshingDeferred?.resolve(result)\n\n        return result\n      }\n\n      this.refreshingDeferred?.reject(error)\n      throw error\n    } finally {\n      this.refreshingDeferred = null\n    }\n  }\n\n  private async _notifyAllSubscribers(\n    event: AuthChangeEvent,\n    session: Session | null,\n    broadcast = true\n  ) {\n    if (this.broadcastChannel && broadcast) {\n      this.broadcastChannel.postMessage({ event, session })\n    }\n\n    const errors: any[] = []\n    const promises = Array.from(this.stateChangeEmitters.values()).map(async (x) => {\n      try {\n        await x.callback(event, session)\n      } catch (e: any) {\n        errors.push(e)\n      }\n    })\n\n    await Promise.all(promises)\n\n    if (errors.length > 0) {\n      for (let i = 0; i < errors.length; i += 1) {\n        console.error(errors[i])\n      }\n\n      throw errors[0]\n    }\n  }\n\n  /**\n   * set currentSession and currentUser\n   * process to _startAutoRefreshToken if possible\n   */\n  private async _saveSession(session: Session) {\n    if (!this.persistSession) {\n      this.inMemorySession = session\n    }\n\n    if (this.persistSession && session.expires_at) {\n      await this._persistSession(session)\n    }\n  }\n\n  private _persistSession(currentSession: Session) {\n    return setItemAsync(this.storage, this.storageKey, currentSession)\n  }\n\n  private async _removeSession() {\n    if (this.persistSession) {\n      await removeItemAsync(this.storage, this.storageKey)\n    } else {\n      this.inMemorySession = null\n    }\n  }\n\n  /**\n   * Removes any registered visibilitychange callback.\n   *\n   * {@see #startAutoRefresh}\n   * {@see #stopAutoRefresh}\n   */\n  private _removeVisibilityChangedCallback() {\n    const callback = this.visibilityChangedCallback\n    this.visibilityChangedCallback = null\n\n    try {\n      if (callback && isBrowser() && window?.removeEventListener) {\n        window.removeEventListener('visibilitychange', callback)\n      }\n    } catch (e) {\n      console.error('removing visibilitychange callback failed', e)\n    }\n  }\n\n  /**\n   * This is the private implementation of {@link #startAutoRefresh}. Use this\n   * within the library.\n   */\n  private async _startAutoRefresh() {\n    await this._stopAutoRefresh()\n\n    const ticker = setInterval(() => this._autoRefreshTokenTick(), AUTO_REFRESH_TICK_DURATION)\n    this.autoRefreshTicker = ticker\n\n    if (ticker && typeof ticker === 'object' && typeof ticker.unref === 'function') {\n      // ticker is a NodeJS Timeout object that has an `unref` method\n      // https://nodejs.org/api/timers.html#timeoutunref\n      // When auto refresh is used in NodeJS (like for testing) the\n      // `setInterval` is preventing the process from being marked as\n      // finished and tests run endlessly. This can be prevented by calling\n      // `unref()` on the returned object.\n      ticker.unref()\n      // @ts-ignore\n    } else if (typeof Deno !== 'undefined' && typeof Deno.unrefTimer === 'function') {\n      // similar like for NodeJS, but with the Deno API\n      // https://deno.land/api@latest?unstable&s=Deno.unrefTimer\n      // @ts-ignore\n      Deno.unrefTimer(ticker)\n    }\n\n    // run the tick immediately\n    await this._autoRefreshTokenTick()\n  }\n\n  /**\n   * This is the private implementation of {@link #stopAutoRefresh}. Use this\n   * within the library.\n   */\n  private async _stopAutoRefresh() {\n    const ticker = this.autoRefreshTicker\n    this.autoRefreshTicker = null\n\n    if (ticker) {\n      clearInterval(ticker)\n    }\n  }\n\n  /**\n   * Starts an auto-refresh process in the background. The session is checked\n   * every few seconds. Close to the time of expiration a process is started to\n   * refresh the session. If refreshing fails it will be retried for as long as\n   * necessary.\n   *\n   * If you set the {@link GoTrueClientOptions#autoRefreshToken} you don't need\n   * to call this function, it will be called for you.\n   *\n   * On browsers the refresh process works only when the tab/window is in the\n   * foreground to conserve resources as well as prevent race conditions and\n   * flooding auth with requests. If you call this method any managed\n   * visibility change callback will be removed and you must manage visibility\n   * changes on your own.\n   *\n   * On non-browser platforms the refresh process works *continuously* in the\n   * background, which may not be desirable. You should hook into your\n   * platform's foreground indication mechanism and call these methods\n   * appropriately to conserve resources.\n   *\n   * {@see #stopAutoRefresh}\n   */\n  async startAutoRefresh() {\n    this._removeVisibilityChangedCallback()\n    await this._startAutoRefresh()\n  }\n\n  /**\n   * Stops an active auto refresh process running in the background (if any).\n   *\n   * If you call this method any managed visibility change callback will be\n   * removed and you must manage visibility changes on your own.\n   *\n   * See {@link #startAutoRefresh} for more details.\n   */\n  async stopAutoRefresh() {\n    this._removeVisibilityChangedCallback()\n    await this._stopAutoRefresh()\n  }\n\n  /**\n   * Runs the auto refresh token tick.\n   */\n  private async _autoRefreshTokenTick() {\n    const now = Date.now()\n\n    try {\n      const {\n        data: { session },\n      } = await this.getSession()\n\n      if (!session || !session.refresh_token || !session.expires_at) {\n        return\n      }\n\n      // session will expire in this many ticks (or has already expired if <= 0)\n      const expiresInTicks = Math.floor(\n        (session.expires_at * 1000 - now) / AUTO_REFRESH_TICK_DURATION\n      )\n\n      if (expiresInTicks < AUTO_REFRESH_TICK_THRESHOLD) {\n        await this._callRefreshToken(session.refresh_token)\n      }\n    } catch (e: any) {\n      console.error('Auto refresh tick failed with error. This is likely a transient error.', e)\n    }\n  }\n\n  /**\n   * Registers callbacks on the browser / platform, which in-turn run\n   * algorithms when the browser window/tab are in foreground. On non-browser\n   * platforms it assumes always foreground.\n   */\n  private async _handleVisibilityChange() {\n    if (!isBrowser() || !window?.addEventListener) {\n      if (this.autoRefreshToken) {\n        // in non-browser environments the refresh token ticker runs always\n        this.startAutoRefresh()\n      }\n\n      return false\n    }\n\n    try {\n      this.visibilityChangedCallback = async () => await this._onVisibilityChanged(false)\n\n      window?.addEventListener('visibilitychange', this.visibilityChangedCallback)\n\n      // now immediately call the visbility changed callback to setup with the\n      // current visbility state\n      await this._onVisibilityChanged(true) // initial call\n    } catch (error) {\n      console.error('_handleVisibilityChange', error)\n    }\n  }\n\n  /**\n   * Callback registered with `window.addEventListener('visibilitychange')`.\n   */\n  private async _onVisibilityChanged(isInitial: boolean) {\n    if (document.visibilityState === 'visible') {\n      if (!isInitial) {\n        // initial visibility change setup is handled in another flow under #initialize()\n        await this.initializePromise\n        await this._recoverAndRefresh()\n      }\n\n      if (this.autoRefreshToken) {\n        // in browser environments the refresh token ticker runs only on focused tabs\n        // which prevents race conditions\n        this._startAutoRefresh()\n      }\n    } else if (document.visibilityState === 'hidden') {\n      if (this.autoRefreshToken) {\n        this._stopAutoRefresh()\n      }\n    }\n  }\n\n  /**\n   * Generates the relevant login URL for a third-party provider.\n   * @param options.redirectTo A URL or mobile address to send the user to after they are confirmed.\n   * @param options.scopes A space-separated list of scopes granted to the OAuth application.\n   * @param options.queryParams An object of key-value pairs containing query parameters granted to the OAuth application.\n   */\n  private async _getUrlForProvider(\n    provider: Provider,\n    options: {\n      redirectTo?: string\n      scopes?: string\n      queryParams?: { [key: string]: string }\n    }\n  ) {\n    const urlParams: string[] = [`provider=${encodeURIComponent(provider)}`]\n    if (options?.redirectTo) {\n      urlParams.push(`redirect_to=${encodeURIComponent(options.redirectTo)}`)\n    }\n    if (options?.scopes) {\n      urlParams.push(`scopes=${encodeURIComponent(options.scopes)}`)\n    }\n    if (this.flowType === 'pkce') {\n      const codeVerifier = generatePKCEVerifier()\n      await setItemAsync(this.storage, `${this.storageKey}-code-verifier`, codeVerifier)\n      const codeChallenge = await generatePKCEChallenge(codeVerifier)\n      const codeChallengeMethod = codeVerifier === codeChallenge ? 'plain' : 's256'\n      const flowParams = new URLSearchParams({\n        code_challenge: `${encodeURIComponent(codeChallenge)}`,\n        code_challenge_method: `${encodeURIComponent(codeChallengeMethod)}`,\n      })\n      urlParams.push(flowParams.toString())\n    }\n    if (options?.queryParams) {\n      const query = new URLSearchParams(options.queryParams)\n      urlParams.push(query.toString())\n    }\n\n    return `${this.url}/authorize?${urlParams.join('&')}`\n  }\n\n  private async _unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      return await _request(this.fetch, 'DELETE', `${this.url}/factors/${params.factorId}`, {\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      })\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#enroll}\n   */\n  private async _enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      const { data, error } = await _request(this.fetch, 'POST', `${this.url}/factors`, {\n        body: {\n          friendly_name: params.friendlyName,\n          factor_type: params.factorType,\n          issuer: params.issuer,\n        },\n        headers: this.headers,\n        jwt: sessionData?.session?.access_token,\n      })\n\n      if (error) {\n        return { data: null, error }\n      }\n\n      if (data?.totp?.qr_code) {\n        data.totp.qr_code = `data:image/svg+xml;utf-8,${data.totp.qr_code}`\n      }\n\n      return { data, error: null }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#verify}\n   */\n  private async _verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      const { data, error } = await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/factors/${params.factorId}/verify`,\n        {\n          body: { code: params.code, challenge_id: params.challengeId },\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        }\n      )\n      if (error) {\n        return { data: null, error }\n      }\n\n      await this._saveSession({\n        expires_at: Math.round(Date.now() / 1000) + data.expires_in,\n        ...data,\n      })\n      await this._notifyAllSubscribers('MFA_CHALLENGE_VERIFIED', data)\n\n      return { data, error }\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#challenge}\n   */\n  private async _challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse> {\n    try {\n      const { data: sessionData, error: sessionError } = await this.getSession()\n      if (sessionError) {\n        return { data: null, error: sessionError }\n      }\n\n      return await _request(\n        this.fetch,\n        'POST',\n        `${this.url}/factors/${params.factorId}/challenge`,\n        {\n          headers: this.headers,\n          jwt: sessionData?.session?.access_token,\n        }\n      )\n    } catch (error) {\n      if (isAuthError(error)) {\n        return { data: null, error }\n      }\n      throw error\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#challengeAndVerify}\n   */\n  private async _challengeAndVerify(\n    params: MFAChallengeAndVerifyParams\n  ): Promise<AuthMFAVerifyResponse> {\n    const { data: challengeData, error: challengeError } = await this._challenge({\n      factorId: params.factorId,\n    })\n    if (challengeError) {\n      return { data: null, error: challengeError }\n    }\n    return await this._verify({\n      factorId: params.factorId,\n      challengeId: challengeData.id,\n      code: params.code,\n    })\n  }\n\n  /**\n   * {@see GoTrueMFAApi#listFactors}\n   */\n  private async _listFactors(): Promise<AuthMFAListFactorsResponse> {\n    const {\n      data: { user },\n      error: userError,\n    } = await this.getUser()\n    if (userError) {\n      return { data: null, error: userError }\n    }\n\n    const factors = user?.factors || []\n    const totp = factors.filter(\n      (factor) => factor.factor_type === 'totp' && factor.status === 'verified'\n    )\n\n    return {\n      data: {\n        all: factors,\n        totp,\n      },\n      error: null,\n    }\n  }\n\n  /**\n   * {@see GoTrueMFAApi#getAuthenticatorAssuranceLevel}\n   */\n  private async _getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse> {\n    const {\n      data: { session },\n      error: sessionError,\n    } = await this.getSession()\n    if (sessionError) {\n      return { data: null, error: sessionError }\n    }\n    if (!session) {\n      return {\n        data: { currentLevel: null, nextLevel: null, currentAuthenticationMethods: [] },\n        error: null,\n      }\n    }\n\n    const payload = this._decodeJWT(session.access_token)\n\n    let currentLevel: AuthenticatorAssuranceLevels | null = null\n\n    if (payload.aal) {\n      currentLevel = payload.aal\n    }\n\n    let nextLevel: AuthenticatorAssuranceLevels | null = currentLevel\n\n    const verifiedFactors =\n      session.user.factors?.filter((factor: Factor) => factor.status === 'verified') ?? []\n\n    if (verifiedFactors.length > 0) {\n      nextLevel = 'aal2'\n    }\n\n    const currentAuthenticationMethods = payload.amr || []\n\n    return { data: { currentLevel, nextLevel, currentAuthenticationMethods }, error: null }\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}